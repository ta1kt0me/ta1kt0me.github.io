(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{Bl7J:function(e,t,n){"use strict";var a=n("dwav"),r=n("q1tI"),c=n.n(r),s=n("Wbzz"),b=function(e){var t=e.siteTitle;return c.a.createElement("header",{style:{background:"white",marginBottom:"1.45rem"}},c.a.createElement("div",{style:{margin:"0 auto",maxWidth:960,padding:"1.45rem 1.0875rem"}},c.a.createElement("h1",{style:{margin:0}},c.a.createElement(s.Link,{to:"/",style:{color:"black",textDecoration:"none"}},t))))};b.defaultProps={siteTitle:""};var o=b;n("8ypT"),t.a=function(e){var t=e.children,n=a.data;return c.a.createElement(c.a.Fragment,null,c.a.createElement(o,{siteTitle:n.site.siteMetadata.title}),c.a.createElement("div",{style:{margin:"0 auto",maxWidth:960,padding:"0 1.0875rem 1.45rem"}},c.a.createElement("main",null,t),c.a.createElement("footer",null,"© ",(new Date).getFullYear(),", Built with"," ",c.a.createElement("a",{href:"https://www.gatsbyjs.org"},"Gatsby"),"by ",n.site.siteMetadata.author)))}},dwav:function(e){e.exports=JSON.parse('{"data":{"site":{"siteMetadata":{"title":"jangajan.com","author":"@ta1kt0me"}}}}')},ot4Y:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return c})),n.d(t,"default",(function(){return o}));n("rGqo"),n("yt8O"),n("Btvt"),n("RW0V"),n("91GP"),n("q1tI");var a=n("7ljp"),r=n("Bl7J");var c={},s={_frontmatter:c},b=r.a;function o(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,a,r={},c=Object.keys(e);for(a=0;a<c.length;a++)n=c[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,["components"]);return Object(a.b)(b,Object.assign({},s,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,"積読消化シリーズの派生です。",Object(a.b)("br",{parentName:"p"}),"\n",Object(a.b)("a",Object.assign({parentName:"p"},{href:"http://tatsu-zine.com/books/naruhounix"}),"なるほどUnixプロセス ― Rubyで学ぶUnixの基礎"),Object(a.b)("br",{parentName:"p"}),"\n","processをforkして動くWebサーバーをThreadで試してみます。  "),Object(a.b)("h1",null,"Threadの簡単な使い方"),Object(a.b)("p",null,"まずはThreadの簡単な使い方です。",Object(a.b)("br",{parentName:"p"}),"\n","一部違いはあるものの、書き方はProcessのfork処理と大きく差はありませんね。  "),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-rb"}),'t1 = Thread.start {\n   puts "スレッド1 id : #{Thread.current}"\n   sleep 1\n}\n\n# t1が終わるまではメインスレッドが待ちになる\nt1.join\nputs "メインスレッド id : #{Thread.current}"\n')),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Thread.start{...}とすると、新しいThreadを生成してブロックを実行します。  "),Object(a.b)("li",{parentName:"ul"},"メインスレッドが終了すると、Threadも終了します。"),Object(a.b)("li",{parentName:"ul"},"Thread#joinを実行すると、対象のThreadの処理が終了するまで待ちます。")),Object(a.b)("p",null,"ちなみに、Threadはメインスレッドと同じProcessで実行されます。",Object(a.b)("br",{parentName:"p"}),"\n","そのため、",Object(a.b)("inlineCode",{parentName:"p"},"ps"),"でrubyのプロセスを確認すると一つしかありません。  "),Object(a.b)("h1",null,"Threadローカルな変数"),Object(a.b)("p",null,"処理プロセスが同じということは、Thread内の処理で変数は共有されることになりますね。",Object(a.b)("br",{parentName:"p"}),"\n","Threadローカルにするためには、Thread.startの引数に渡します。  "),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-rb"}),'access_count = 0\nt1 = Thread.start(access_count) {|ac|\n   puts "スレッド1 id : #{Thread.current} #{ac += 1}" => 1\n   sleep 1\n}\nt1.join\nputs "メインスレッド id : #{Thread.current} #{access_count += 1}" => 1\n')),Object(a.b)("h1",null,"複数Threadを待ちたい"),Object(a.b)("p",null,"Thread#joinは特定のThreadを待ちます。",Object(a.b)("br",{parentName:"p"}),"\n","Webサーバーの例では複数のProcessを管理していました。",Object(a.b)("br",{parentName:"p"}),"\n","同様のことをThreadで実行するには、",Object(a.b)("inlineCode",{parentName:"p"},"ThreadsWait"),"を使います。  "),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-rb"}),'require \'thwait\'\nworker_threads = []\n5.times {\n  worker_threads << Thread.start {\n     puts "スレッド1 id : #{Thread.current} "\n     sleep 1\n  }\n}\n# ThreadsWait.all_waitsで全てのThreadの処理終了を待つ\nThreadsWait.all_waits(worker_threads)\nputs "メインスレッド id : #{Thread.current} #{access_count += 1}" => 1\n')),Object(a.b)("h1",null,"複数Threadでリクエストを処理するWebサーバー"),Object(a.b)("p",null,"それでは上記を踏まえて、複数Threadで処理するWebサーバーを書いてみます。"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-rb"}),"#!/usr/bin/env ruby\n\nrequire 'socket'\nrequire 'time'\nrequire 'thwait'\n\nsocket = TCPServer.open '127.0.0.1', 8080\n\naccess_count = 0\n\nworker_threads = []\n5.times {\n  # access_countはThreadローカルにする\n  worker_threads << Thread.start(access_count){|ac|\n    # threadの処理\n    loop {\n      response_body = \"Hello Browser! #{ac += 1}\"\n      connection = socket.accept\n      connection.puts ['HTTP/1.1 200 OK',\n                     \"Date: #{Time.now.httpdate}\",\n                     'Server: Ruby',\n                     'Content-Type: text/html; charset=utf-8',\n                     \"Content-Length: #{response_body.length}\\r\\n\\r\\n\"].join(\"\\r\\n\")\n      connection.puts response_body\n      connection.close\n    }\n  }\n}\n\n# メインスレッドを待ちにする\nThreadsWait.all_waits(worker_threads)\n")),Object(a.b)("p",null,"実際のところ、",Object(a.b)("inlineCode",{parentName:"p"},"socket"),"を複数Threadで共有した場合どうなるか、とかは調査する必要がありますね。",Object(a.b)("br",{parentName:"p"}),"\n","ただ、Threadで置き換えることもできたということで。",Object(a.b)("br",{parentName:"p"}),"\n","これでも一応動きます。  "))}o.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-2014-09-07-unix-thread-socket-server-in-ruby-md-505c63c0fdb5d5f32c58.js.map