(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{Bl7J:function(e,n,t){"use strict";var r=t("dwav"),a=t("q1tI"),o=t.n(a),c=t("Wbzz"),l=function(e){var n=e.siteTitle;return o.a.createElement("header",{style:{background:"white",marginBottom:"1.45rem"}},o.a.createElement("div",{style:{margin:"0 auto",maxWidth:960,padding:"1.45rem 1.0875rem"}},o.a.createElement("h1",{style:{margin:0}},o.a.createElement(c.Link,{to:"/",style:{color:"black",textDecoration:"none"}},n))))};l.defaultProps={siteTitle:""};var b=l;t("8ypT"),n.a=function(e){var n=e.children,t=r.data;return o.a.createElement(o.a.Fragment,null,o.a.createElement(b,{siteTitle:t.site.siteMetadata.title}),o.a.createElement("div",{style:{margin:"0 auto",maxWidth:960,padding:"0 1.0875rem 1.45rem"}},o.a.createElement("main",null,n),o.a.createElement("footer",null,"© ",(new Date).getFullYear(),", Built with"," ",o.a.createElement("a",{href:"https://www.gatsbyjs.org"},"Gatsby"),"by ",t.site.siteMetadata.author)))}},dwav:function(e){e.exports=JSON.parse('{"data":{"site":{"siteMetadata":{"title":"jangajan.com","author":"@ta1kt0me"}}}}')},lJ33:function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return o})),t.d(n,"default",(function(){return b}));t("rGqo"),t("yt8O"),t("Btvt"),t("RW0V"),t("91GP"),t("q1tI");var r=t("7ljp"),a=t("Bl7J");var o={},c={_frontmatter:o},l=a.a;function b(e){var n=e.components,t=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,["components"]);return Object(r.b)(l,Object.assign({},c,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("p",null,"積読消化シリーズです。",Object(r.b)("br",{parentName:"p"}),"\n",Object(r.b)("a",Object.assign({parentName:"p"},{href:"http://tatsu-zine.com/books/naruhounix"}),"なるほどUnixプロセス ― Rubyで学ぶUnixの基礎"),Object(r.b)("br",{parentName:"p"}),"\n","簡単なWebサーバーを作ります。  "),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"telnetでアクセスするWebサーバー"),Object(r.b)("li",{parentName:"ul"},"ブラウザでアクセスするWebサーバー"),Object(r.b)("li",{parentName:"ul"},"forkしたProcessでリクエストを処理するWebサーバー")),Object(r.b)("h1",null,"telnetでアクセスするWebサーバー"),Object(r.b)("p",null,"まずはtelnetでアクセスするためのシンプルなWebサーバーを用意します。  "),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-rb"}),"#!/usr/bin/env ruby\n\nrequire 'socket'\n\n# 127.0.0.1(localhost)で8080ポートで立ち上げる\nsocket = TCPServer.open '127.0.0.1', 8080\n\nloop {\n  connection = socket.accept\n  connection.puts 'Hello Readers!'\n  connection.close\n}\n")),Object(r.b)("p",null,"サーバーを起動し、ターミナルを立ち上げて、telnetでアクセスしてみます。"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-sh"}),"telnet 127.0.0.1 8080\n=> Hello Readers!\n")),Object(r.b)("p",null,"ただし、このままだとブラウザで",Object(r.b)("inlineCode",{parentName:"p"},"http://127.0.0.1:8080"),"にアクセスできません。",Object(r.b)("br",{parentName:"p"}),"\n","次はブラウザでアクセスできるように修正します。"),Object(r.b)("h1",null,"ブラウザでアクセスするWebサーバー"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-rb"}),"#!/usr/bin/env ruby\n\nrequire 'socket'\nrequire 'time'\n\nsocket = TCPServer.open '127.0.0.1', 8080\n\nloop {\n  connection = socket.accept\n  # response headerを設定\n  connection.puts ['HTTP/1.1 200 OK',\n                   \"Date: #{Time.now.httpdate}\",\n                   'Server: Ruby',\n                   'Content-Type: text/html; charset=utf-8',\n                   \"Content-Length: #{response_body.length}\\r\\n\\r\\n\"].join(\"\\r\\n\")\n  # response bodyを設定\n  connection.puts 'Hello Readers!'\n  connection.close\n}\n")),Object(r.b)("p",null,"レスポンスのヘッダー情報を追加しました。",Object(r.b)("br",{parentName:"p"}),"\n","ヘッダーとボディは改行",Object(r.b)("inlineCode",{parentName:"p"},"\\r\\n"),"で区切ります。  "),Object(r.b)("p",null,"これでブラウザでアクセスできるようになりました。"),Object(r.b)("h1",null,"forkしたProcessでリクエストを処理するWebサーバー"),Object(r.b)("p",null,"続いては、アクセスを子プロセスで処理するように変更します。"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-rb"}),"#!/usr/bin/env ruby                           \nrequire 'socket'\nrequire 'time'\n\nsocket = TCPServer.open '127.0.0.1', 8080\n\nworker_pid = fork do\n  # 子プロセスで処理\n  loop {\n    response_body = 'Hello Browser!'\n    connection = socket.accept\n    connection.puts ['HTTP/1.1 200 OK',\n                   \"Date: #{Time.now.httpdate}\",\n                   'Server: Ruby',\n                   'Content-Type: text/html; charset=utf-8',\n                   \"Content-Length: #{response_body.length}\\r\\n\\r\\n\"].join(\"\\r\\n\")\n    connection.puts response_body\n    connection.close\n  }\nend\n\n# Signalを受け取ったらprocessをkillする\n[:INT, :QUIT].each do |signal|\n  Signal.trap(signal) {\n    Process.kill(signal, worker_pid)\n  }\nend\n\n# 親プロセスの処理を待ちにする\nProcess.waitpid worker_pid\n")),Object(r.b)("p",null,"forkで子プロセスを生成し、リクエストを子プロセスで処理しています。",Object(r.b)("br",{parentName:"p"}),"\n","親プロセスは子プロセスが処理が完了するまでwaitします。",Object(r.b)("br",{parentName:"p"}),"\n","(子プロセスはloop処理を行っているため、シグナルを受け取るまでは生き続けます)"))}b.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-2014-09-05-unix-process-socket-server-in-ruby-md-477c3aa1e26a30038841.js.map