<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | JanGaJan.com]]></title>
  <link href="http://ta1kt0me.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://ta1kt0me.github.io/"/>
  <updated>2016-02-17T01:24:37+09:00</updated>
  <id>http://ta1kt0me.github.io/</id>
  <author>
    <name><![CDATA[talkto_me]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rubyでのパフォーマンス改善]]></title>
    <link href="http://ta1kt0me.github.io/blog/2015/11/22/profile-ruby/"/>
    <updated>2015-11-22T13:29:37+09:00</updated>
    <id>http://ta1kt0me.github.io/blog/2015/11/22/profile-ruby</id>
    <content type="html"><![CDATA[<p>Rubyでのパフォーマンス改善に挑戦してみます。
やることとしては以下に絞って確認してみます。</p>

<ul>
<li>benchmarkを使って実行時間を計測</li>
<li>stackprofを使ってメソッドの呼び出し状況を確認</li>
</ul>


<!-- more -->


<p>例えば、Railsアプリで、PostsController#indexでDBからPostをランダムに10件取得する処理があるとします。
ちなみに、<code>posts</code>テーブルには10万件のレコードがあります。</p>

<pre><code class="rb">class PostsController &lt; ApplicationController
  def index
    @posts = Post.all.sample(10)
  end
end
</code></pre>

<h1>計測用モジュールを作成する</h1>

<p>Ruby2.2には<code>prepend</code>という計測時に便利なメソッドが追加されました。</p>

<p><code>#{app.root}/lib</code>に、<code>app_performance.rb</code>という計測用のモジュールを追加してみます。</p>

<pre><code class="rb">module AppPerformance
  def index
    p '始まるよ'
    super
    p '終わるよ'
  end
end
</code></pre>

<p>ついでに、<code>autoload_paths</code>に<code>#{Rails.root}/lib</code>を追加するのを忘れないでください。
そして、<code>PostsController</code>側でこの<code>AppPerfonce</code>モジュールを<code>prepend</code>してみます。</p>

<pre><code class="rb">class PostsController &lt; ApplicationController
  prepend AppPerformance

  def index
    @posts = Post.all.sample(10)
  end
end
</code></pre>

<p>これでindexページにアクセスしてみましょう。ログがSQLの前後に表示されていることが確認できますね。</p>

<pre><code>Started GET "/posts" for 127.0.0.1 at 2015-11-22 14:30:54 +0900
Processing by PostsController#index as HTML
"始まるよ"
  Post Load (773.0ms)  SELECT "posts".* FROM "posts"  ORDER BY "posts"."published_at" DESC
"終わるよ"
  Rendered posts/index.html.erb within layouts/application (3.0ms)
Completed 200 OK in 1943ms (Views: 45.3ms | ActiveRecord: 773.5ms)
</code></pre>

<p>準備が整ったので<code>index</code>の処理時間を確認してみましょう。</p>

<h1>処理時間を計測する</h1>

<p><a href="http://docs.ruby-lang.org/ja/2.2.0/library/benchmark.html">benchmark</a>ライブラリを使用してみます。</p>

<pre><code class="rb">module AppPerformance
  def index
    result = Benchmark.measure do
      super
    end
    File.open('tmp/benchmark_before.txt', 'w') {|f| f.write(result) }
  end
end
</code></pre>

<p>実行結果を確認してみます。</p>

<pre><code>$ cat tmp/benchmark_before.txt
1.710000   0.110000   1.820000 (  2.208176) )
</code></pre>

<p>カッコ内が呼び出しから実行までにかかった時間です。
<code>2.20</code>はだいぶかかっていますねー。</p>

<h1>関数の呼び出し状況を計測する</h1>

<p>次に、<a href="https://github.com/tmm1/stackprof">stackprof</a>を利用して関数の呼び出し状況を確認してみましょう。</p>

<p><code>stackprof</code>をインストールします。</p>

<pre><code class="sh">echo "gem 'stackprof' &gt;&gt; Gemfile"
bundle install
</code></pre>

<p>次に<code>app_performance.rb</code>を修正します。
<code>rb
module AppPerformance
  def index
    result = Benchmark.measure do
      StackProf.run(mode: :cpu, raw: true, out: "tmp/stackprof-cpu_before.dump") do
        super
      end
    end
    File.open('tmp/benchmark_before.txt', 'w') {|f| f.write(result) }
  end
end
</code></p>

<p><code>stackprof</code>コマンドで実行結果を確認します。</p>

<pre><code class="sh">$ bundle exec stackprof --text tmp/stackprof-cpu_before.dump --limit 5
==================================
  Mode: cpu(1000)
  Samples: 1236 (0.00% miss rate)
  GC: 440 (35.60%)
==================================
     TOTAL    (pct)     SAMPLES    (pct)     FRAME
       319  (25.8%)         319  (25.8%)     block in SQLite3::Statement#each
       151  (12.2%)         151  (12.2%)     block in ActiveRecord::Result#hash_rows
       325  (26.3%)          85   (6.9%)     block in ActiveRecord::Result#each
        67   (5.4%)          67   (5.4%)     ActiveRecord::Core#init_internals
        62   (5.0%)          31   (2.5%)     ActiveRecord::ModelSchema::ClassMethods#inheritance_column==================================
</code></pre>

<p>使用率の高い上位5つのメソッドを表示しました。当然ですが、ARやDB周りのメソッド呼び出しが多いですね。</p>

<h1>改善</h1>

<p><code>sample</code>の利用をやめて、DBで事前にソートするようにしました。
DB依存のコードになってしまいますが、余計な処理を省くためにsqlite3の<code>RANDOM()</code>関数を使用します。</p>

<pre><code class="rb">class PostsController &lt; ApplicationController
  prepend AppPerformance

  def index
    @posts = Post.order('RANDOM()').take(10)
  end
end
</code></pre>

<p>結果はこちら。</p>

<pre><code>$ cat tmp/benchmark_after.txt
  0.090000   0.060000   0.150000 (  0.252615)

$ bundle exec stackprof --text tmp/stackprof-cpu_after.dump --limit 5
==================================
  Mode: cpu(1000)
  Samples: 18 (86.47% miss rate)
  GC: 0 (0.00%)
==================================
     TOTAL    (pct)     SAMPLES    (pct)     FRAME
         3  (16.7%)           3  (16.7%)     ActiveRecord::Core::ClassMethods#arel_table
         2  (11.1%)           2  (11.1%)     ActiveRecord::Base.logger
         2  (11.1%)           2  (11.1%)     block in SQLite3::Statement#each
         1   (5.6%)           1   (5.6%)     Arel::Collectors::PlainString#&lt;&lt;
         1   (5.6%)           1   (5.6%)     block in SQLite3::Statement#get_metadata
</code></pre>

<p>ちなみに<code>take</code>ではなく<code>limit</code>を利用すると、計測数値はさらに向上します。(<code>render</code>処理での実行時間は遅くなりますが)</p>

<p>だいぶ極端な例になりましたが、<code>benchmark</code>や<code>stackprof</code>を利用することで、改善のポイントや勘所が絞り込みやすくなります。
今回試してみて思ったのはテストしやすいコードは計測しもしやすいコードになりやすそう。
また、<code>prepend</code>メソッドは必要以上の変更をせずにメソッドをフックしたいケースで非常に使いやすいです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rubyとrailsのdelegate]]></title>
    <link href="http://ta1kt0me.github.io/blog/2015/08/14/ruby-rails-delegate/"/>
    <updated>2015-08-14T02:05:49+09:00</updated>
    <id>http://ta1kt0me.github.io/blog/2015/08/14/ruby-rails-delegate</id>
    <content type="html"><![CDATA[<p>委譲があまりよくわかっていなかったのでメモ。継承よりは使いやすそう。</p>

<!-- more -->


<h1>rubyのdelegate</h1>

<p>Forwardableクラスに委譲のメソッドがあります。</p>

<pre><code class="ruby">require 'forwardable'

class Hoge
  extend Forwardable

  # also: def_delegators :@delegator, :name, :age
  delegate [:name, :age] =&gt; :@delegator

  def initialize args
    @delegator = args == 'nakachi' ? Nakachi.new : Tanaka.new
  end

  class Nakachi
    def name; 'I am Nakachi' end
    def age; 100 end
  end

  class Tanaka
    def name; 'I am Tanaka' end
    def age; 10 end
  end
end

hoge = Hoge.new 'nakachi'
puts hoge.name #=&gt; 'I am Nakachi'
puts hoge.age  #=&gt; 100
</code></pre>

<h1>railsのdelegate</h1>

<p><code>activesupport</code>でModuleのインスタンスメソッドとして定義されています。</p>

<pre><code class="ruby">require 'active_support'
require 'active_support/core_ext'

module DelegatorFuga
  delegate :name, :age, to: :delegator

  class Nakachi
    def name; 'I am Nakachi' end
    def age; 100 end
  end

  class Tanaka
    def name; 'I am Tanaka' end
    def age; 10 end
  end
end

class Fuga
  include DelegatorFuga

  attr_reader :delegator

  def initialize args
    @delegator = args == 'nakachi' ? DelegatorFuga::Nakachi.new : DelegatorFuga::Tanaka.new
  end
end

fuga = Fuga.new 'nakachi'
puts fuga.name #=&gt; 'I am Nakachi'
puts fuga.age  #=&gt; 100
</code></pre>

<p>こっちには、<code>prefix</code>と<code>allow_nil</code>というオプションがある。</p>

<h2>allow_nil</h2>

<p>委譲先がnilの場合でもメソッド呼び出し時にnilを返してくれるようになる。</p>

<pre><code class="ruby">&gt; delegate :name, :age, to: :delegator, allow_nil: true
&gt; @delegator = args == 'nakachi' ? nil : DelegatorFuga::Tanaka.new

fuga = Fuga.new 'nakachi'
# method_missingは発生しない
puts fuga.name #=&gt; nil
puts fuga.age  #=&gt; nil
</code></pre>

<h2>prefix</h2>

<p>delegateしたメソッドのprefixをつける。この場合、prefixをつけない形式でメソッドを呼び出すことはできなくなる。</p>

<pre><code class="ruby">&gt; delegate :name, :age, to: :delegator, prefix: true

fuga = Fuga.new 'nakachi'
puts fuga.delegator_name
puts fuga.delegator_age
</code></pre>

<pre><code class="ruby">&gt; delegate :name, :age, to: :delegator, prefix: :my

fuga = Fuga.new 'nakachi'
puts fuga.my_name
puts fuga.my_age
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MetaNight 第6回を開催しました]]></title>
    <link href="http://ta1kt0me.github.io/blog/2015/03/07/e-g-d-meta-night-6th/"/>
    <updated>2015-03-07T01:02:02+09:00</updated>
    <id>http://ta1kt0me.github.io/blog/2015/03/07/e-g-d-meta-night-6th</id>
    <content type="html"><![CDATA[<p>イベント概要については、<a href="/blog/2014/11/02/about-meta-night/">About MetaNight</a>をご覧ください。</p>

<p><a href="http://e-g-d.doorkeeper.jp/">MetaNight</a>という<a href="http://www.amazon.co.jp/gp/product/B00N9I0RMQ/ref=as_li_ss_il?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=B00N9I0RMQ&amp;linkCode=as2&amp;tag=pochan0919-22">Metaprogramming Ruby 2</a>の読書会の第６回目を開催しました。</p>

<p><a href="http://www.amazon.co.jp/gp/product/B00N9I0RMQ/ref=as_li_ss_il?ie=UTF8&camp=247&creative=7399&creativeASIN=B00N9I0RMQ&linkCode=as2&tag=pochan0919-22"><img border="0" src="http://ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&ASIN=B00N9I0RMQ&Format=_SL250_&ID=AsinImage&MarketPlace=JP&ServiceVersion=20070822&WS=1&tag=pochan0919-22" ></a><img src="http://ir-jp.amazon-adsystem.com/e/ir?t=pochan0919-22&l=as2&o=9&a=B00N9I0RMQ" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></p>

<!-- more -->


<h1>活動内容</h1>

<p>Part 1 Chapter2 の <code>Constant</code> から <code>the rake example</code> の前までやりました。<br/>
読みながらの意見とかはこちらに載せてあります。<br/>
<a href="https://trello.com/b/OZ3llmtE/metanight-6th">https://trello.com/b/OZ3llmtE/metanight-6th</a></p>

<h1>感想</h1>

<p>今回は初の一人会(いつも皆様ありがとうございます)だったので、同日あった別イベントに参加しつつ読み進めました。<br/>
雑談メインになったので、そんなに進まなかった。</p>

<h2>Constant is like in a file system</h2>

<p>定数の基本的な話です。同じ定数名だとしても、定義しているスコープが違えば、別物として扱います。そのため、仕組みとしてはファイルシステムを連想するとイメージしやすいです。例えば、別ディレクトリにあるファイルは、ファイル名が一緒でも別ファイルになります。定数も同様、同じ定数名でも、定義しているスコープが違えば参照する値は異なります。</p>

<ul>
<li>定数の先頭は大文字

<ul>
<li>クラス名やモジュール名は定数である</li>
</ul>
</li>
<li>定数を上書き可能だが、警告が発生</li>
</ul>


<h2>英語</h2>

<ul>
<li>have to do with</li>
</ul>


<p>関係がある</p>

<ul>
<li>go even further</li>
</ul>


<p>さらに掘り下げる</p>

<h2>その他</h2>

<ul>
<li>酒弱いので、飲むと記憶力が薄まる</li>
<li>Rubyは面白い</li>
<li>沖縄合宿行きたい</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[STIを試す]]></title>
    <link href="http://ta1kt0me.github.io/blog/2015/03/06/try-sti/"/>
    <updated>2015-03-06T05:43:15+09:00</updated>
    <id>http://ta1kt0me.github.io/blog/2015/03/06/try-sti</id>
    <content type="html"><![CDATA[<h1>Single Table Inheritance(STI)とは</h1>

<p>単一テーブル継承というデザインパターンです。テーブルベースの継承階層を表現しています。Ruby同様、継承元は一つのテーブルだけです。<br/>
<a href="http://www.martinfowler.com/eaaCatalog/singleTableInheritance.html">こちら</a>に具体的なイメージがあります。<br/>
早速RailsでSTIをどうやるのか調べてみます。</p>

<!-- more -->


<h1>環境</h1>

<table>
<thead>
<tr>
<th style="text-align:left;">tool</th>
<th style="text-align:right;">version</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">ruby</td>
<td style="text-align:right;">2.2.0</td>
</tr>
<tr>
<td style="text-align:left;">rails</td>
<td style="text-align:right;">4.2.0</td>
</tr>
</tbody>
</table>


<h1>試す</h1>

<p>まずは準備をします。</p>

<pre><code class="sh">$ bundle exec rails new sti_type --no-test-framework --skip-bundle
$ bundle exec rails g model user name:string age:integer type:string
$ bundle exec rake db:migrate
</code></pre>

<p>RailsでのSTIではmodelの <code>type</code> というカラムが重要な役割を果たします。</p>

<pre><code class="rb app/models/guest.rb">class Guest &lt; User; end
</code></pre>

<pre><code class="rb app/models/host.rb">class Host &lt; User; end
</code></pre>

<p>継承ツリーとしてはこんな感じになります。</p>

<pre><code>ActiveRecord::Base
        |
       User
   _____|_____
  |           |
Guest        Host
</code></pre>

<p>これで一通りの準備が整いました。 <code>rails console</code> で動作を確認してみます。</p>

<pre><code class="rb">$ bundle exec rails c
&gt; Guest.create(name: 'Mark', age: 18)
&gt; Host.create(name: 'Yamada', age: 50)

&gt; pp User.all
[#&lt;Guest:0x007f84c1279a00
  id: 1,
  name: "Mark",
  age: 18,
  type: "Guest",
  created_at: Thu, 05 Mar 2015 19:43:24 UTC +00:00,
  updated_at: Thu, 05 Mar 2015 19:43:24 UTC +00:00&gt;,
 #&lt;Host:0x007f84c1279870
  id: 2,
  name: "Yamada",
  age: 50,
  type: "Host",
  created_at: Thu, 05 Mar 2015 19:44:02 UTC +00:00,
  updated_at: Thu, 05 Mar 2015 19:44:02 UTC +00:00&gt;]

&gt; pp Guest.all
[#&lt;Guest:0x007f84c2b54b10
  id: 1,
  name: "Mark",
  age: 18,
  type: "Guest",
  created_at: Thu, 05 Mar 2015 19:43:24 UTC +00:00,
  updated_at: Thu, 05 Mar 2015 19:43:24 UTC +00:00&gt;]
</code></pre>

<p><code>type</code> に、自分のクラス名がGuestだったら&#8217;Guest&#8217;と入ります。 <code>Guest</code> だけの属性を集めたい場合は <code>Guest.all</code> とすることで取得できます。</p>

<h1><code>type</code>以外のカラムにクラス情報を格納したい</h1>

<p>なにがしかの理由で <code>type</code> は使えない場合、 <code>self.inheritance_column</code> を使うことで、別のカラムをクラス名を格納するカラムに指定することができます。
例えば、 <code>role</code> というカラムを使いたい場合です。</p>

<h2>準備</h2>

<p>汚いですが前のサンプルをそのまま使います。<br/>
<code>role</code>というカラムを追加します。</p>

<pre><code>$ bundle exec rails g migration AddRoleToUser
</code></pre>

<pre><code class="rb db/migrate/20150305201347_add_role_to_user.rb">class AddRoleToUser &lt; ActiveRecord::Migration
  def change
    add_column :users, :role, :string
  end
end
</code></pre>

<p>データを綺麗にしたいのでDB作り直します。
<code>sh
$ bundle exec rake db:setup
$ bundle exec rake db:migrate
</code></p>

<p>大事なのはここだけです。 <code>self.inheritance_column</code> に <code>role</code> を指定します。</p>

<pre><code class="rb app/models/user.rb">class User &lt; ActiveRecord::Base
  self.inheritance_column = :role
end
</code></pre>

<h2>確認</h2>

<pre><code class="rb ">&gt; Guest.create(name: 'Bob', age: 1000)
&gt; Host.create(name: 'Tanaka', age: 100)
&gt; pp User.all
[#&lt;Guest:0x007fe248c19c60
  id: 3,
  name: "Bob",
  age: 1000,
  type: nil,
  created_at: Thu, 05 Mar 2015 20:23:55 UTC +00:00,
  updated_at: Thu, 05 Mar 2015 20:23:55 UTC +00:00,
  role: "Guest"&gt;,
 #&lt;Host:0x007fe248c19ad0
  id: 4,
  name: "Tanaka",
  age: 100,
  type: nil,
  created_at: Thu, 05 Mar 2015 20:24:10 UTC +00:00,
  updated_at: Thu, 05 Mar 2015 20:24:10 UTC +00:00,
  role: "Host"&gt;]
</code></pre>

<p><code>type</code> ではなく、 <code>role</code> を使用していることが確認できました。</p>

<h1>注意点</h1>

<p>注意しなければいけなそうな点は、こんな感じでしょうか。</p>

<ul>
<li>子クラス(<code>Guest</code> や <code>Host</code>)ごとに特別のカラムが欲しい場合、 <code>users</code> に追加する必要があり、<code>nil</code>を許容しなければいけない

<ul>
<li><code>Guest</code> で使うが <code>Host</code> では使用しないケースがあるから</li>
</ul>
</li>
<li>子クラスごとに、カラムの型を変えることはできない</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gem Reading - Dotenv]]></title>
    <link href="http://ta1kt0me.github.io/blog/2015/02/16/gem-reading-dotenv/"/>
    <updated>2015-02-16T17:27:40+09:00</updated>
    <id>http://ta1kt0me.github.io/blog/2015/02/16/gem-reading-dotenv</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/bkeepers/dotenv">dotenv</a>というGemを知ったので覗いてみました。</p>

<!-- more -->


<h1>about dotevn</h1>

<p>読む前にどんなものか簡単に確認。</p>

<h2>これなに？</h2>

<p>環境変数 ENV をファイル管理できるGemです。<a href="http://qiita.com/closer/items/f8d8ba00ae86d7051764">こちら</a>の記事が参考になりました。</p>

<h2>どう使うの？</h2>

<pre><code class="rb Gemfile"># 後でbundle install
gem 'dotenv'
</code></pre>

<p>デフォルトでは<code>.env</code>というファイルの中に、
<code>yml .env
HOGE=1
FUGA=2
</code>
と書いて、<code>.env</code>を読み込むための命令 <code>Dotenv.load</code> を実行すると、 <code>ENV['HOGE']</code> が <code>1</code> を返すようになります。環境変数をわざわざexportコマンドを使ったり、<code>.zshrc</code>といった設定ファイルに書かなくても使えるようになります。<br/>
fixtureを見た感じ<code>=</code>じゃなくて、YAMLっぽく<code>:</code>も使えそう。</p>

<h1>読んでみる</h1>

<h2>2つのGem</h2>

<p>このGemからは2つのGemを利用できます。</p>

<pre><code class="ruby Gemfile">source 'https://rubygems.org'
gemspec :name =&gt; 'dotenv'
gemspec :name =&gt; 'dotenv-rails'
</code></pre>

<p>gemspecファイルも2つあった。<br/>
<code>dotenv</code>というGemはこの機能のベース部分。<code>dotenv-rails</code>というGemは、Railsを利用するときに、<code>dotenv</code>を自動で有効にしてくれるラッパーです。それと、このGemにはCLIのスクリプトも包含しています。</p>

<h2>dotenv.rb</h2>

<p>ここが外部から呼び出すインターフェースのメソッド(load, load!, overload)を定義しています。<code>module Dotenv extend self</code>として、これらをmoduleの特異メソッドにしています。<br/>
環境変数を定義するファイルをこのメソッドの引数として渡せばいいが、引数なしの場合は <code>.env</code> がデフォルト値となります。</p>

<p>まだ分かっていないのですが、 <code>instrument</code> というメソッドは、 <code>Active Support Instrumentation</code> という機能を使っている。  この機能はRails限定。</p>

<p><code>reduce</code>が使われているんだけど、<code>inject</code> とどう使い分けするのかなって疑問に思ったら<a href="http://magazine.rubyist.net/?0038-MapAndCollect#l4">こんな記事</a>がありました。smalltalkとlispの考え方の違いか〜&hellip;実際にはaliasだから使う人の好みが出そう。</p>

<h2>environment.rb</h2>

<p><code>Dotenv::Environment</code>は<code>Hash</code>の子クラス。<code>.env</code>内のkey,value情報を自身に格納して、<code>apply</code> or <code>apply!</code> を呼び出すことで<code>ENV</code>に設定している。<code>apply</code>メソッドの呼び出しは、<code>dotenv.rb</code>で行っている。<code>Dotenv::Environment</code>の<code>initialize</code>の一部として<code>.env</code>の読み込みとパースをやってる。</p>

<h2>parse.rb</h2>

<p>大事なのは<code>call</code>メソッド。ここで<code>.env</code>の内容がパースされる。正規表現弱いんでこのあたりは宿題&hellip;orz<br/>
<code>@@substitutions</code>というクラス変数があるんだけどここには<code>Substitutions</code>のnamespaceにあるクラスの配列が入ってる。<code>.env</code>のvalueに設定できるものとして、</p>

<ol>
<li>コマンドの出力結果</li>
<li>変数展開</li>
</ol>


<p>がある。
1 は <code>Dotenv::Substitutions::Command</code>で処理し、2 は<code>Dotenv::Substitutions::Variable</code>で処理する。  あー、実際にはそうなるように値を設定しているのかな？</p>

<p>Substitutions.constants のところでクラス名が定数だということがわかった。</p>

<h2>rails.rb</h2>

<p>デフォルトでは、<code>before_configuration</code>のときに、<code>.env</code>を読み込む。<code>dotenv</code>と違い、ファイル名は<code>.env.local</code>,<code>.env.#{Rails.env}</code>もデフォルトで読み込み対象となる。</p>

<p>それと、上述の<code>Active Support Instrumentation</code>をspringによるファイル変更時のENV再設定に利用しているっぽい。この通知の仕組み？をもうちょっと掘り下げてみようかな。</p>

<h1>終わりに</h1>

<p>英語が堪能は方は<a href="http://blog.mah-lab.com/2014/08/15/dotenv/">こちら</a>が参考になるかも。全然内容が頭の中に入ってこなかったのでもっとリスニング練習しよう。</p>
]]></content>
  </entry>
  
</feed>
