<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | JanGaJan.com]]></title>
  <link href="http://ta1kt0me.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://ta1kt0me.github.io/"/>
  <updated>2017-03-04T09:44:23+09:00</updated>
  <id>http://ta1kt0me.github.io/</id>
  <author>
    <name><![CDATA[talkto_me]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails Generateで作ったrubyファイルにfrozen String Literalのコメントを追加する]]></title>
    <link href="http://ta1kt0me.github.io/blog/2017/03/04/add-comment-for-frozen-string-literal-in-rails-generate/"/>
    <updated>2017-03-04T09:59:30+09:00</updated>
    <id>http://ta1kt0me.github.io/blog/2017/03/04/add-comment-for-frozen-string-literal-in-rails-generate</id>
    <content type="html"><![CDATA[<p><code>rails generate</code> したファイルにいちいちfrozen string literalのコメント追加するのは面倒ですよね。<br/>
ということでモンキーパッチ。</p>

<!-- more -->


<p>railsの5.1.0.beta1が公開されている時のmasterで試しました。
initializerに入れておけば動く。</p>

<p><a href="https://gist.github.com/ta1kt0me/6a7058d16621785d4f7038bde6cd3b98">Add frozen string literal comment into generated files in rails v5.1.0</a></p>

<pre><code>module AddFrozenStringLiteralComment
  def add_frozen_string_literal_comment(dist)
    if File.exist?(dist) &amp;&amp; File.extname(dist) == '.rb'
      File.open(dist, 'r') do |f|
        body = f.read

        File.open(dist, 'w') do |new_f|
          new_f.write("# frozen_string_literal: true\n" + body)
        end
      end
    end
  end
end

module GeneratorPrepend
  include AddFrozenStringLiteralComment

  def invoke!
    res = super
    add_frozen_string_literal_comment(existing_migration)
    res
  end
end

module TemplatePrepend
  include AddFrozenStringLiteralComment

  def template(source, *args, &amp;block)
    res = super
    add_frozen_string_literal_comment(args.first)
    res
  end
end

Rails::Generators::Migration
Rails::Generators::Actions::CreateMigration.send :prepend, GeneratorPrepend
Rails::Generators::NamedBase.send :prepend, TemplatePrepend
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rubyで素数計算]]></title>
    <link href="http://ta1kt0me.github.io/blog/2016/03/18/prime-number/"/>
    <updated>2016-03-18T00:01:44+09:00</updated>
    <id>http://ta1kt0me.github.io/blog/2016/03/18/prime-number</id>
    <content type="html"><![CDATA[<p>AOJの0009で素数の数を計算する問題。パフォーマンスがうまく解決できなかった。</p>

<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0009">http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0009</a></p>

<!-- more -->


<ul>
<li>2以外の偶数は探索対象としない</li>
<li>最大値の平方根より大きい値は探索対象としない</li>
</ul>


<pre><code class="rb">max = 199_999
res = (5..max).to_a.delete_if(&amp;:even?).each_with_object([2, 3]) do |e, a|
  limit = Math.sqrt(e).round
  lst = a.take_while { |i| i &lt; limit }
  a.push e unless lst.any? { |i| e % i == 0 }
end
puts res.count
</code></pre>

<p>結果はあってるけど、タイムアウトした&hellip;</p>

<p><a href="https://www.wikiwand.com/ja/%E3%82%A8%E3%83%A9%E3%83%88%E3%82%B9%E3%83%86%E3%83%8D%E3%82%B9%E3%81%AE%E7%AF%A9">エラトステネスの篩</a>をやってみた。</p>

<pre><code class="rb">max = 199_999
lst = (2..max).to_a
result = []
sqrt = Math.sqrt(max)

loop do
  elem = lst.shift
  result &lt;&lt; elem
  break if elem &gt;= sqrt
  lst.delete_if { |i| i % elem == 0 }
end

puts (result + lst).count
</code></pre>

<p>これでもタイムアウト&hellip;</p>

<p><a href="http://docs.ruby-lang.org/ja/2.3.0/library/prime.html">Prime</a>という素数を扱うライブラリがあったので使ってみる。
<code>rb
require 'prime'
max = 199_999
Prime.each(max).count
</code></p>

<p>せっかくなのでbenchmark-ipsで計測。</p>

<pre><code class="rb">require 'benchmark/ips'

Benchmark.ips do |x|
  def calc
    max = 199_999
    res = (5..max).to_a.delete_if(&amp;:even?).each_with_object([2, 3]) do |e, a|
      limit = Math.sqrt(e).round
      lst = a.take_while { |i| i &lt; limit }
      a.push e unless lst.any? { |i| e % i == 0 }
    end
    res.count
  end

  def eratostenes
    max = 199_999
    lst = (2..max).to_a
    result = []
    sqrt = Math.sqrt(max)

    loop do
      elem = lst.shift
      result &lt;&lt; elem
      break if elem &gt;= sqrt
      lst.delete_if { |i| i % elem == 0 }
    end

    (result + lst).count
  end

  def prime
    require 'prime'
    max = 199_999
    Prime.each(max).count
  end

  x.config(time: 10, warmup: 2)
  x.report('calc') { calc }
  x.report('eratostenes') { eratostenes }
  x.report('prime') { prime }
  x.compare!
end

Warming up --------------------------------------
                calc     1.000  i/100ms
         eratostenes     1.000  i/100ms
               prime    21.000  i/100ms
Calculating -------------------------------------
                calc      0.596  (± 0.0%) i/s -      6.000
         eratostenes      4.838  (±20.7%) i/s -     46.000
               prime    195.376  (±21.5%) i/s -      1.848k

Comparison:
               prime:      195.4 i/s
         eratostenes:        4.8 i/s - 40.39x slower
                calc:        0.6 i/s - 327.62x slower
</code></pre>

<p>Prime早い&hellip;エラトステネスの篩も最初のやり方に比べたらかなり早いですね。Primeどうやっているんだろう。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rubyでのパフォーマンス改善]]></title>
    <link href="http://ta1kt0me.github.io/blog/2015/11/22/profile-ruby/"/>
    <updated>2015-11-22T13:29:37+09:00</updated>
    <id>http://ta1kt0me.github.io/blog/2015/11/22/profile-ruby</id>
    <content type="html"><![CDATA[<p>Rubyでのパフォーマンス改善に挑戦してみます。
やることとしては以下に絞って確認してみます。</p>

<ul>
<li>benchmarkを使って実行時間を計測</li>
<li>stackprofを使ってメソッドの呼び出し状況を確認</li>
</ul>


<!-- more -->


<p>例えば、Railsアプリで、PostsController#indexでDBからPostをランダムに10件取得する処理があるとします。
ちなみに、<code>posts</code>テーブルには10万件のレコードがあります。</p>

<pre><code class="rb">class PostsController &lt; ApplicationController
  def index
    @posts = Post.all.sample(10)
  end
end
</code></pre>

<h1>計測用モジュールを作成する</h1>

<p>Ruby2.2には<code>prepend</code>という計測時に便利なメソッドが追加されました。</p>

<p><code>#{app.root}/lib</code>に、<code>app_performance.rb</code>という計測用のモジュールを追加してみます。</p>

<pre><code class="rb">module AppPerformance
  def index
    p '始まるよ'
    super
    p '終わるよ'
  end
end
</code></pre>

<p>ついでに、<code>autoload_paths</code>に<code>#{Rails.root}/lib</code>を追加するのを忘れないでください。
そして、<code>PostsController</code>側でこの<code>AppPerfonce</code>モジュールを<code>prepend</code>してみます。</p>

<pre><code class="rb">class PostsController &lt; ApplicationController
  prepend AppPerformance

  def index
    @posts = Post.all.sample(10)
  end
end
</code></pre>

<p>これでindexページにアクセスしてみましょう。ログがSQLの前後に表示されていることが確認できますね。</p>

<pre><code>Started GET "/posts" for 127.0.0.1 at 2015-11-22 14:30:54 +0900
Processing by PostsController#index as HTML
"始まるよ"
  Post Load (773.0ms)  SELECT "posts".* FROM "posts"  ORDER BY "posts"."published_at" DESC
"終わるよ"
  Rendered posts/index.html.erb within layouts/application (3.0ms)
Completed 200 OK in 1943ms (Views: 45.3ms | ActiveRecord: 773.5ms)
</code></pre>

<p>準備が整ったので<code>index</code>の処理時間を確認してみましょう。</p>

<h1>処理時間を計測する</h1>

<p><a href="http://docs.ruby-lang.org/ja/2.2.0/library/benchmark.html">benchmark</a>ライブラリを使用してみます。</p>

<pre><code class="rb">module AppPerformance
  def index
    result = Benchmark.measure do
      super
    end
    File.open('tmp/benchmark_before.txt', 'w') {|f| f.write(result) }
  end
end
</code></pre>

<p>実行結果を確認してみます。</p>

<pre><code>$ cat tmp/benchmark_before.txt
1.710000   0.110000   1.820000 (  2.208176) )
</code></pre>

<p>カッコ内が呼び出しから実行までにかかった時間です。
<code>2.20</code>はだいぶかかっていますねー。</p>

<h1>関数の呼び出し状況を計測する</h1>

<p>次に、<a href="https://github.com/tmm1/stackprof">stackprof</a>を利用して関数の呼び出し状況を確認してみましょう。</p>

<p><code>stackprof</code>をインストールします。</p>

<pre><code class="sh">echo "gem 'stackprof' &gt;&gt; Gemfile"
bundle install
</code></pre>

<p>次に<code>app_performance.rb</code>を修正します。
<code>rb
module AppPerformance
  def index
    result = Benchmark.measure do
      StackProf.run(mode: :cpu, raw: true, out: "tmp/stackprof-cpu_before.dump") do
        super
      end
    end
    File.open('tmp/benchmark_before.txt', 'w') {|f| f.write(result) }
  end
end
</code></p>

<p><code>stackprof</code>コマンドで実行結果を確認します。</p>

<pre><code class="sh">$ bundle exec stackprof --text tmp/stackprof-cpu_before.dump --limit 5
==================================
  Mode: cpu(1000)
  Samples: 1236 (0.00% miss rate)
  GC: 440 (35.60%)
==================================
     TOTAL    (pct)     SAMPLES    (pct)     FRAME
       319  (25.8%)         319  (25.8%)     block in SQLite3::Statement#each
       151  (12.2%)         151  (12.2%)     block in ActiveRecord::Result#hash_rows
       325  (26.3%)          85   (6.9%)     block in ActiveRecord::Result#each
        67   (5.4%)          67   (5.4%)     ActiveRecord::Core#init_internals
        62   (5.0%)          31   (2.5%)     ActiveRecord::ModelSchema::ClassMethods#inheritance_column==================================
</code></pre>

<p>使用率の高い上位5つのメソッドを表示しました。当然ですが、ARやDB周りのメソッド呼び出しが多いですね。</p>

<h1>改善</h1>

<p><code>sample</code>の利用をやめて、DBで事前にソートするようにしました。
DB依存のコードになってしまいますが、余計な処理を省くためにsqlite3の<code>RANDOM()</code>関数を使用します。</p>

<pre><code class="rb">class PostsController &lt; ApplicationController
  prepend AppPerformance

  def index
    @posts = Post.order('RANDOM()').take(10)
  end
end
</code></pre>

<p>結果はこちら。</p>

<pre><code>$ cat tmp/benchmark_after.txt
  0.090000   0.060000   0.150000 (  0.252615)

$ bundle exec stackprof --text tmp/stackprof-cpu_after.dump --limit 5
==================================
  Mode: cpu(1000)
  Samples: 18 (86.47% miss rate)
  GC: 0 (0.00%)
==================================
     TOTAL    (pct)     SAMPLES    (pct)     FRAME
         3  (16.7%)           3  (16.7%)     ActiveRecord::Core::ClassMethods#arel_table
         2  (11.1%)           2  (11.1%)     ActiveRecord::Base.logger
         2  (11.1%)           2  (11.1%)     block in SQLite3::Statement#each
         1   (5.6%)           1   (5.6%)     Arel::Collectors::PlainString#&lt;&lt;
         1   (5.6%)           1   (5.6%)     block in SQLite3::Statement#get_metadata
</code></pre>

<p>ちなみに<code>take</code>ではなく<code>limit</code>を利用すると、計測数値はさらに向上します。(<code>render</code>処理での実行時間は遅くなりますが)</p>

<p>だいぶ極端な例になりましたが、<code>benchmark</code>や<code>stackprof</code>を利用することで、改善のポイントや勘所が絞り込みやすくなります。
今回試してみて思ったのはテストしやすいコードは計測しもしやすいコードになりやすそう。
また、<code>prepend</code>メソッドは必要以上の変更をせずにメソッドをフックしたいケースで非常に使いやすいです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rubyとrailsのdelegate]]></title>
    <link href="http://ta1kt0me.github.io/blog/2015/08/14/ruby-rails-delegate/"/>
    <updated>2015-08-14T02:05:49+09:00</updated>
    <id>http://ta1kt0me.github.io/blog/2015/08/14/ruby-rails-delegate</id>
    <content type="html"><![CDATA[<p>委譲があまりよくわかっていなかったのでメモ。継承よりは使いやすそう。</p>

<!-- more -->


<h1>rubyのdelegate</h1>

<p>Forwardableクラスに委譲のメソッドがあります。</p>

<pre><code class="ruby">require 'forwardable'

class Hoge
  extend Forwardable

  # also: def_delegators :@delegator, :name, :age
  delegate [:name, :age] =&gt; :@delegator

  def initialize args
    @delegator = args == 'nakachi' ? Nakachi.new : Tanaka.new
  end

  class Nakachi
    def name; 'I am Nakachi' end
    def age; 100 end
  end

  class Tanaka
    def name; 'I am Tanaka' end
    def age; 10 end
  end
end

hoge = Hoge.new 'nakachi'
puts hoge.name #=&gt; 'I am Nakachi'
puts hoge.age  #=&gt; 100
</code></pre>

<h1>railsのdelegate</h1>

<p><code>activesupport</code>でModuleのインスタンスメソッドとして定義されています。</p>

<pre><code class="ruby">require 'active_support'
require 'active_support/core_ext'

module DelegatorFuga
  delegate :name, :age, to: :delegator

  class Nakachi
    def name; 'I am Nakachi' end
    def age; 100 end
  end

  class Tanaka
    def name; 'I am Tanaka' end
    def age; 10 end
  end
end

class Fuga
  include DelegatorFuga

  attr_reader :delegator

  def initialize args
    @delegator = args == 'nakachi' ? DelegatorFuga::Nakachi.new : DelegatorFuga::Tanaka.new
  end
end

fuga = Fuga.new 'nakachi'
puts fuga.name #=&gt; 'I am Nakachi'
puts fuga.age  #=&gt; 100
</code></pre>

<p>こっちには、<code>prefix</code>と<code>allow_nil</code>というオプションがある。</p>

<h2>allow_nil</h2>

<p>委譲先がnilの場合でもメソッド呼び出し時にnilを返してくれるようになる。</p>

<pre><code class="ruby">&gt; delegate :name, :age, to: :delegator, allow_nil: true
&gt; @delegator = args == 'nakachi' ? nil : DelegatorFuga::Tanaka.new

fuga = Fuga.new 'nakachi'
# method_missingは発生しない
puts fuga.name #=&gt; nil
puts fuga.age  #=&gt; nil
</code></pre>

<h2>prefix</h2>

<p>delegateしたメソッドのprefixをつける。この場合、prefixをつけない形式でメソッドを呼び出すことはできなくなる。</p>

<pre><code class="ruby">&gt; delegate :name, :age, to: :delegator, prefix: true

fuga = Fuga.new 'nakachi'
puts fuga.delegator_name
puts fuga.delegator_age
</code></pre>

<pre><code class="ruby">&gt; delegate :name, :age, to: :delegator, prefix: :my

fuga = Fuga.new 'nakachi'
puts fuga.my_name
puts fuga.my_age
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MetaNight 第6回を開催しました]]></title>
    <link href="http://ta1kt0me.github.io/blog/2015/03/07/e-g-d-meta-night-6th/"/>
    <updated>2015-03-07T01:02:02+09:00</updated>
    <id>http://ta1kt0me.github.io/blog/2015/03/07/e-g-d-meta-night-6th</id>
    <content type="html"><![CDATA[<p>イベント概要については、<a href="/blog/2014/11/02/about-meta-night/">About MetaNight</a>をご覧ください。</p>

<p><a href="http://e-g-d.doorkeeper.jp/">MetaNight</a>という<a href="http://www.amazon.co.jp/gp/product/B00N9I0RMQ/ref=as_li_ss_il?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=B00N9I0RMQ&amp;linkCode=as2&amp;tag=pochan0919-22">Metaprogramming Ruby 2</a>の読書会の第６回目を開催しました。</p>

<p><a href="http://www.amazon.co.jp/gp/product/B00N9I0RMQ/ref=as_li_ss_il?ie=UTF8&camp=247&creative=7399&creativeASIN=B00N9I0RMQ&linkCode=as2&tag=pochan0919-22"><img border="0" src="http://ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&ASIN=B00N9I0RMQ&Format=_SL250_&ID=AsinImage&MarketPlace=JP&ServiceVersion=20070822&WS=1&tag=pochan0919-22" ></a><img src="http://ir-jp.amazon-adsystem.com/e/ir?t=pochan0919-22&l=as2&o=9&a=B00N9I0RMQ" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></p>

<!-- more -->


<h1>活動内容</h1>

<p>Part 1 Chapter2 の <code>Constant</code> から <code>the rake example</code> の前までやりました。<br/>
読みながらの意見とかはこちらに載せてあります。<br/>
<a href="https://trello.com/b/OZ3llmtE/metanight-6th">https://trello.com/b/OZ3llmtE/metanight-6th</a></p>

<h1>感想</h1>

<p>今回は初の一人会(いつも皆様ありがとうございます)だったので、同日あった別イベントに参加しつつ読み進めました。<br/>
雑談メインになったので、そんなに進まなかった。</p>

<h2>Constant is like in a file system</h2>

<p>定数の基本的な話です。同じ定数名だとしても、定義しているスコープが違えば、別物として扱います。そのため、仕組みとしてはファイルシステムを連想するとイメージしやすいです。例えば、別ディレクトリにあるファイルは、ファイル名が一緒でも別ファイルになります。定数も同様、同じ定数名でも、定義しているスコープが違えば参照する値は異なります。</p>

<ul>
<li>定数の先頭は大文字

<ul>
<li>クラス名やモジュール名は定数である</li>
</ul>
</li>
<li>定数を上書き可能だが、警告が発生</li>
</ul>


<h2>英語</h2>

<ul>
<li>have to do with</li>
</ul>


<p>関係がある</p>

<ul>
<li>go even further</li>
</ul>


<p>さらに掘り下げる</p>

<h2>その他</h2>

<ul>
<li>酒弱いので、飲むと記憶力が薄まる</li>
<li>Rubyは面白い</li>
<li>沖縄合宿行きたい</li>
</ul>

]]></content>
  </entry>
  
</feed>
