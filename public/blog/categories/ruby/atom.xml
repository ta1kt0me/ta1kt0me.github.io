<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | JanGaJan.com]]></title>
  <link href="http://jangajan.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://jangajan.com/"/>
  <updated>2014-11-02T17:40:41+09:00</updated>
  <id>http://jangajan.com/</id>
  <author>
    <name><![CDATA[talkto_me]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[MetaNight 第1回を開催しました]]></title>
    <link href="http://jangajan.com/blog/2014/11/01/e-g-d-meta-night-1st/"/>
    <updated>2014-11-01T01:42:36+09:00</updated>
    <id>http://jangajan.com/blog/2014/11/01/e-g-d-meta-night-1st</id>
    <content type="html"><![CDATA[<p><a href="http://e-g-d.doorkeeper.jp/events/16300">MetaNight</a>という<a href="http://www.amazon.co.jp/gp/product/B00N9I0RMQ/ref=as_li_ss_il?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=B00N9I0RMQ&amp;linkCode=as2&amp;tag=pochan0919-22">Metaprogramming Ruby 2</a>の読書会の第１回目を開催しました。</p>

<p><a href="http://www.amazon.co.jp/gp/product/B00N9I0RMQ/ref=as_li_ss_il?ie=UTF8&camp=247&creative=7399&creativeASIN=B00N9I0RMQ&linkCode=as2&tag=pochan0919-22"><img border="0" src="http://ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&ASIN=B00N9I0RMQ&Format=_SL250_&ID=AsinImage&MarketPlace=JP&ServiceVersion=20070822&WS=1&tag=pochan0919-22" ></a><img src="http://ir-jp.amazon-adsystem.com/e/ir?t=pochan0919-22&l=as2&o=9&a=B00N9I0RMQ" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></p>

<!-- more -->


<p>第一回目。<br/>
このイベント自体は @tkymtk さんの発案による共同運営という形で開催しました。<br/>
諸事情で次回からは一人でやることになりそうなので宣伝・備忘録がてらにどんなものか紹介します。</p>

<p>気が向いたら遊びにきてください。</p>

<h1>MetaNightについて</h1>

<h2>コンセプト</h2>

<p><strong>英語の技術書を楽しく読む！</strong></p>

<p>技術書読むのって結構精神削られますよね&hellip;<br/>
しかも英語とか&hellip;もぅ</p>

<p>けど、英語、ちょっと読めるようになりたいしなぁ&hellip;<br/>
と、くすぶっている方にはピッタリです。<br/>
(自分がそんな感じ)</p>

<p>後、黙々と読むだけではなくって、話したいです。(超大事。雑談楽しい)<br/>
英語か技術どっちか片方にで興味がある人がいたら話したいのでぜひ。<br/>
公用語は日本語です。安心してください。</p>

<h2>イベント概要</h2>

<p>英語の技術書を読むことを目的とした「エイゴ・ギジュツショ・ドクショカイ」というdoorkeeperのコミュニティによる、meta programming ruby 2の読書会です。</p>

<p>技術(主にRuby)と英語がテーマです。<br/>
少人数で、雑談混じりでワイワイやってます。<br/>
今日のペースだと読み終わるのは２年後かなぁ</p>

<h2>参加するために必要なもの</h2>

<ul>
<li>meta programming ruby 2とそれを読める機械

<ul>
<li><a href="http://www.amazon.co.jp/gp/product/B00N9I0RMQ/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=B00N9I0RMQ&amp;linkCode=as2&amp;tag=pochan0919-22">kindle</a></li>
<li><a href="https://pragprog.com/book/ppmetr2/metaprogramming-ruby-2">epub</a></li>
</ul>
</li>
<li>doorkeeperへの参加申込</li>
<li>ビールやコーヒー一杯分の小銭</li>
<li>仕事を切り上げる気持ち</li>
</ul>


<h2>興味のある方へ</h2>

<p>doorkeeperへコメントやtwitter(<a href="https://twitter.com/talkto_me">@talkto_me</a>)へのダイレクトメッセージお待ちしてます。</p>

<p>補足です。</p>

<ul>
<li>英語が不安</li>
</ul>


<p>iBook使うと辞書引きやすくて楽です。<br/>
分かりづらい場合なんかは共有時間に確認したりします。</p>

<ul>
<li>Rubyがわからない</li>
</ul>


<p>メタプログラミングなので、基本的なところは分かっておく必要があります。<br/>
ドットインストールでのRubyの収録をチラ見しておくと良いです。</p>

<hr />

<p>以下、本日の振り返り。<br/>
写真とっておけばよかった&hellip;</p>

<h1>第1回</h1>

<p>3名での開催でした。</p>

<h2>進め方</h2>

<p>情報共有にはTrelloを使いました。<br/>
読みながら気になった点があればカードを作成し、共有時間に見直しました。</p>

<p>時間的的には、4:6で共有もとい雑談時間の方がやや多め。<br/>
今回は手探り感満載で２つの方法を試しました。</p>

<h3>1. 読む時間決めて、黙々と読む。</h3>

<p>まずはこのやり方で始めました。<br/>
時間を決めて参加者それぞれで読み進める。<br/>
時間がきたら気になったところをそれぞれ話してく。</p>

<h3>2. どこまで読むか決めて、読み終わったら共有</h3>

<p>1のやり方で進めると先に進みすぎたりした時に前の内容が抜け落ちたりするという提案があったので、この方法を試す事にしました。<br/>
遅い人（僕です）のペースにあわせてもらって読み進めました。<br/>
結果的に同じ範囲で気になる点を話し合えたので、こちらのスタイルの方で続ける事に。</p>

<h2>反省・感想</h2>

<ul>
<li>使った店がお洒落</li>
<li>ハロウィンで客が少なかったおかげなのか、優雅なソファーでくつろげた</li>
<li>楽しくて延長して3時間やってしまった</li>
<li>実は2時間経ったら、店員からドリンク催促があったんです</li>
<li>Noと言えない</li>
<li>一緒にやる人がいると、自分で読み流しているところに気がつける(2回目の超大事)</li>
<li>自分で書く時に前置詞の使い方が難しい</li>
<li>そんな人たち向けにおすすめを紹介してもらった！ <a href="http://www.amazon.co.jp/gp/product/4890855270/ref=as_li_ss_tl?ie=UTF8&camp=247&creative=7399&creativeASIN=4890855270&linkCode=as2&tag=pochan0919-22">一億人の英文法 ――すべての日本人に贈る「話すため」の英文法（東進ブックス）</a><img src="http://ir-jp.amazon-adsystem.com/e/ir?t=pochan0919-22&l=as2&o=9&a=4890855270" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li>Trelloでの共有が便利</li>
<li>カードのクローズとかのやり方は次回までの課題</li>
<li>Hangoutも使えるようにしたい</li>
<li>英語の微妙なニュアンスを日本語で落とし込むのが難しい(知恵が欲しい)</li>
<li>いきなりActiveRecordかよ</li>
<li>悟りを開ければGuru</li>
<li>ダイヤルMってなんなんだろう</li>
<li>頻繁に使われるruntime</li>
<li>yangとyin。英語じゃないじゃん、そりゃ辞書に無いわ。</li>
<li>ghost townとmarket、C++とRuby</li>
<li>introspection、stick、entrench、derive、at one&rsquo;s disposal、nagging、a bolt-on power feature、自分一人じゃニュアンス掴めなかった</li>
<li>おすすめ！ <a href="http://gilesbowkett.blogspot.jp/2007/11/why-i-program-in-ruby-and-maybe-why-you.html">http://gilesbowkett.blogspot.jp/2007/11/why-i-program-in-ruby-and-maybe-why-you.html</a></li>
<li>忘れないように、2週間間隔で開催できるといいな</li>
</ul>


<h1>最後に</h1>

<p>見出しぐらい英語でかけるようになりたい<br/>
今月中に第2回を開く</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rubyでメソッドを定義しているクラスを調べたい]]></title>
    <link href="http://jangajan.com/blog/2014/10/28/which-of-the-class-dose-have-the-method/"/>
    <updated>2014-10-28T05:55:25+09:00</updated>
    <id>http://jangajan.com/blog/2014/10/28/which-of-the-class-dose-have-the-method</id>
    <content type="html"><![CDATA[<p>メソッドを定義していくクラスを探る方法です。</p>

<!-- more -->


<h1>定義しているClassを知りたい</h1>

<p>クラス名だけを知りたいのであれば<code>Method#owner</code>を利用します。</p>

<pre><code class="rb"># singleton method
String.method(:try_convert).owner
=&gt; #&lt;Class:String&gt;

# instance method
"s".method(:method_missing).owner
=&gt; BasicObject
</code></pre>

<h1>もうちょっと詳しい情報が知りたい</h1>

<p><code>Method#inspect</code>を使うともう少し詳しい情報を取得できます。
といってもそんなに大きく変わりません。</p>

<pre><code class="rb"># singleton method
String.method(:try_convert).inspect
=&gt; "#&lt;Method: String.try_convert&gt;"

# instance method
"s".method(:method_missing).inspect
=&gt; "#&lt;Method: String(BasicObject)#method_missing&gt;"
</code></pre>

<p>当たり前の話ですが、特異メソッド(クラスメソッド、singleton method)は継承されないですね。
どいうことかというと、DateTimeクラスでは、Dateクラスの得意メソッドを呼び出せない、ということに気付かされました。
クラスメソッドに対してownerとかするの意味ねぇ。</p>

<h1>定義している場所を知りたい</h1>

<p>1.9以降(1.9.3?)では<code>Method#source_location</code>というメソッドで、メソッドの定義された具体的な場所の情報が分かります。
ただし、取得できるのはrubyで定義されたものに限るようです。
(ネイティブで定義されているメソッドの場合nilになる)</p>

<pre><code class="rb"># singleton method
ActiveRecord::Base.method(:where).source_location
=&gt; ["#{APP_ROOT}/vendor/bundle/ruby/2.0.0/gems/activerecord-4.0.2/lib/active_record/querying.rb", 7]

# instance method
"".method(:blank?).source_location
=&gt; ["#{APP_ROOT}/vendor/bundle/ruby/2.0.0/gems/activesupport-4.0.2/lib/active_support/core_ext/object/blank.rb", 92]

# ネイティブで定義されたメソッドはnilを返す
"s".method(:method_missing).source_location
=&gt; nil
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[メモ : Array#each_with_objectの簡単な使い方]]></title>
    <link href="http://jangajan.com/blog/2014/10/27/each-with-object-memo/"/>
    <updated>2014-10-27T18:50:07+09:00</updated>
    <id>http://jangajan.com/blog/2014/10/27/each-with-object-memo</id>
    <content type="html"><![CDATA[<p>each_with_objectの簡単な使い方。
使い方は気をつけないといけないですね。</p>

<!-- more -->


<pre><code class="rb">[1,2,3].each_with_object(n=[]){|v| n &lt;&lt; v + 5}
=&gt; [6, 7, 8]
# nを初期化しないで処理
[1,2,3].each_with_object(n){|v| n &lt;&lt; v + 5}
=&gt; [6, 7, 8, 6, 7, 8]
[1,2,3].each_with_object(n){|v| n &lt;&lt; v + 5}
=&gt; [6, 7, 8, 6, 7, 8, 6, 7, 8]
# nをeach_with_objectで初期化
[1,2,3].each_with_object(n=[]){|v| n &lt;&lt; v + 5}
=&gt; [6, 7, 8]
# nをeach_with_objectの前に宣言
n = [10]
=&gt; [10]
[1,2,3].each_with_object(n){|v| n &lt;&lt; v + 5}
=&gt; [10, 6, 7, 8]
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RubyのThreadを利用したWebサーバーを作る]]></title>
    <link href="http://jangajan.com/blog/2014/09/07/unix-thread-socket-server-in-ruby/"/>
    <updated>2014-09-07T03:15:15+09:00</updated>
    <id>http://jangajan.com/blog/2014/09/07/unix-thread-socket-server-in-ruby</id>
    <content type="html"><![CDATA[<p>積読消化シリーズの派生です。<br/>
<a href="http://tatsu-zine.com/books/naruhounix">なるほどUnixプロセス ― Rubyで学ぶUnixの基礎</a><br/>
processをforkして動くWebサーバーをThreadで試してみます。</p>

<!-- more -->


<h1>Threadの簡単な使い方</h1>

<p>まずはThreadの簡単な使い方です。<br/>
一部違いはあるものの、書き方はProcessのfork処理と大きく差はありませんね。</p>

<pre><code class="rb">t1 = Thread.start {
   puts "スレッド1 id : #{Thread.current}"
   sleep 1
}

# t1が終わるまではメインスレッドが待ちになる
t1.join
puts "メインスレッド id : #{Thread.current}"
</code></pre>

<ul>
<li>Thread.start{&hellip;}とすると、新しいThreadを生成してブロックを実行します。</li>
<li>メインスレッドが終了すると、Threadも終了します。</li>
<li>Thread#joinを実行すると、対象のThreadの処理が終了するまで待ちます。</li>
</ul>


<p>ちなみに、Threadはメインスレッドと同じProcessで実行されます。<br/>
そのため、<code>ps</code>でrubyのプロセスを確認すると一つしかありません。</p>

<h1>Threadローカルな変数</h1>

<p>処理プロセスが同じということは、Thread内の処理で変数は共有されることになりますね。<br/>
Threadローカルにするためには、Thread.startの引数に渡します。</p>

<pre><code class="rb">access_count = 0
t1 = Thread.start(access_count) {|ac|
   puts "スレッド1 id : #{Thread.current} #{ac += 1}" =&gt; 1
   sleep 1
}
t1.join
puts "メインスレッド id : #{Thread.current} #{access_count += 1}" =&gt; 1
</code></pre>

<h1>複数Threadを待ちたい</h1>

<p>Thread#joinは特定のThreadを待ちます。<br/>
Webサーバーの例では複数のProcessを管理していました。<br/>
同様のことをThreadで実行するには、<code>ThreadsWait</code>を使います。</p>

<pre><code class="rb">require 'thwait'
worker_threads = []
5.times {
  worker_threads &lt;&lt; Thread.start {
     puts "スレッド1 id : #{Thread.current} "
     sleep 1
  }
}
# ThreadsWait.all_waitsで全てのThreadの処理終了を待つ
ThreadsWait.all_waits(worker_threads)
puts "メインスレッド id : #{Thread.current} #{access_count += 1}" =&gt; 1
</code></pre>

<h1>複数Threadでリクエストを処理するWebサーバー</h1>

<p>それでは上記を踏まえて、複数Threadで処理するWebサーバーを書いてみます。</p>

<pre><code class="rb">#!/usr/bin/env ruby

require 'socket'
require 'time'
require 'thwait'

socket = TCPServer.open '127.0.0.1', 8080

access_count = 0

worker_threads = []
5.times {
  # access_countはThreadローカルにする
  worker_threads &lt;&lt; Thread.start(access_count){|ac|
    # threadの処理
    loop {
      response_body = "Hello Browser! #{ac += 1}"
      connection = socket.accept
      connection.puts ['HTTP/1.1 200 OK',
                     "Date: #{Time.now.httpdate}",
                     'Server: Ruby',
                     'Content-Type: text/html; charset=utf-8',
                     "Content-Length: #{response_body.length}\r\n\r\n"].join("\r\n")
      connection.puts response_body
      connection.close
    }
  }
}

# メインスレッドを待ちにする
ThreadsWait.all_waits(worker_threads)
</code></pre>

<p>実際のところ、<code>socket</code>を複数Threadで共有した場合どうなるか、とかは調査する必要がありますね。<br/>
ただ、Threadで置き換えることもできたということで。<br/>
これでも一応動きます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RubyのProcessを利用したWebサーバーを作る]]></title>
    <link href="http://jangajan.com/blog/2014/09/05/unix-process-socket-server-in-ruby/"/>
    <updated>2014-09-05T19:08:20+09:00</updated>
    <id>http://jangajan.com/blog/2014/09/05/unix-process-socket-server-in-ruby</id>
    <content type="html"><![CDATA[<p>積読消化シリーズです。<br/>
<a href="http://tatsu-zine.com/books/naruhounix">なるほどUnixプロセス ― Rubyで学ぶUnixの基礎</a><br/>
簡単なWebサーバーを作ります。</p>

<ul>
<li>telnetでアクセスするWebサーバー</li>
<li>ブラウザでアクセスするWebサーバー</li>
<li>forkしたProcessでリクエストを処理するWebサーバー</li>
</ul>


<!-- more -->


<h1>telnetでアクセスするWebサーバー</h1>

<p>まずはtelnetでアクセスするためのシンプルなWebサーバーを用意します。</p>

<pre><code class="rb">#!/usr/bin/env ruby

require 'socket'

# 127.0.0.1(localhost)で8080ポートで立ち上げる
socket = TCPServer.open '127.0.0.1', 8080

loop {
  connection = socket.accept
  connection.puts 'Hello Readers!'
  connection.close
}
</code></pre>

<p>サーバーを起動し、ターミナルを立ち上げて、telnetでアクセスしてみます。</p>

<pre><code class="sh">telnet 127.0.0.1 8080
=&gt; Hello Readers!
</code></pre>

<p>ただし、このままだとブラウザで<code>http://127.0.0.1:8080</code>にアクセスできません。<br/>
次はブラウザでアクセスできるように修正します。</p>

<h1>ブラウザでアクセスするWebサーバー</h1>

<pre><code class="rb">#!/usr/bin/env ruby

require 'socket'
require 'time'

socket = TCPServer.open '127.0.0.1', 8080

loop {
  connection = socket.accept
  # response headerを設定
  connection.puts ['HTTP/1.1 200 OK',
                   "Date: #{Time.now.httpdate}",
                   'Server: Ruby',
                   'Content-Type: text/html; charset=utf-8',
                   "Content-Length: #{response_body.length}\r\n\r\n"].join("\r\n")
  # response bodyを設定
  connection.puts 'Hello Readers!'
  connection.close
}
</code></pre>

<p>レスポンスのヘッダー情報を追加しました。<br/>
ヘッダーとボディは改行<code>\r\n</code>で区切ります。</p>

<p>これでブラウザでアクセスできるようになりました。</p>

<h1>forkしたProcessでリクエストを処理するWebサーバー</h1>

<p>続いては、アクセスを子プロセスで処理するように変更します。</p>

<pre><code class="rb">#!/usr/bin/env ruby                           
require 'socket'
require 'time'

socket = TCPServer.open '127.0.0.1', 8080

worker_pid = fork do
  # 子プロセスで処理
  loop {
    response_body = 'Hello Browser!'
    connection = socket.accept
    connection.puts ['HTTP/1.1 200 OK',
                   "Date: #{Time.now.httpdate}",
                   'Server: Ruby',
                   'Content-Type: text/html; charset=utf-8',
                   "Content-Length: #{response_body.length}\r\n\r\n"].join("\r\n")
    connection.puts response_body
    connection.close
  }
end

# Signalを受け取ったらprocessをkillする
[:INT, :QUIT].each do |signal|
  Signal.trap(signal) {
    Process.kill(signal, worker_pid)
  }
end

# 親プロセスの処理を待ちにする
Process.waitpid worker_pid
</code></pre>

<p>forkで子プロセスを生成し、リクエストを子プロセスで処理しています。<br/>
親プロセスは子プロセスが処理が完了するまでwaitします。<br/>
(子プロセスはloop処理を行っているため、シグナルを受け取るまでは生き続けます)</p>
]]></content>
  </entry>
  
</feed>
