<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Jangajan.com]]></title>
  <link href="http://jangajan.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://jangajan.com/"/>
  <updated>2014-09-08T03:50:35+09:00</updated>
  <id>http://jangajan.com/</id>
  <author>
    <name><![CDATA[talkto_me]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[RubyのThreadを利用したWebサーバーを作る]]></title>
    <link href="http://jangajan.com/blog/2014/09/07/unix-thread-socket-server-in-ruby/"/>
    <updated>2014-09-07T03:15:15+09:00</updated>
    <id>http://jangajan.com/blog/2014/09/07/unix-thread-socket-server-in-ruby</id>
    <content type="html"><![CDATA[<p>積読消化シリーズの派生です。<br/>
<a href="http://tatsu-zine.com/books/naruhounix">なるほどUnixプロセス ― Rubyで学ぶUnixの基礎</a><br/>
processをforkして動くWebサーバーをThreadで試してみます。</p>

<h1>Threadの簡単な使い方</h1>

<p>まずはThreadの簡単な使い方です。<br/>
一部違いはあるものの、書き方はProcessのfork処理と大きく差はありませんね。</p>

<pre><code class="rb">t1 = Thread.start {
   puts "スレッド1 id : #{Thread.current}"
   sleep 1
}

# t1が終わるまではメインスレッドが待ちになる
t1.join
puts "メインスレッド id : #{Thread.current}"
</code></pre>

<ul>
<li>Thread.start{&hellip;}とすると、新しいThreadを生成してブロックを実行します。</li>
<li>メインスレッドが終了すると、Threadも終了します。</li>
<li>Thread#joinを実行すると、対象のThreadの処理が終了するまで待ちます。</li>
</ul>


<p>ちなみに、Threadはメインスレッドと同じProcessで実行されます。<br/>
そのため、<code>ps</code>でrubyのプロセスを確認すると一つしかありません。</p>

<h1>Threadローカルな変数</h1>

<p>処理プロセスが同じということは、Thread内の処理で変数は共有されることになりますね。<br/>
Threadローカルにするためには、Thread.startの引数に渡します。</p>

<pre><code class="rb">access_count = 0
t1 = Thread.start(access_count) {|ac|
   puts "スレッド1 id : #{Thread.current} #{ac += 1}" =&gt; 1
   sleep 1
}
t1.join
puts "メインスレッド id : #{Thread.current} #{access_count += 1}" =&gt; 1
</code></pre>

<h1>複数Threadを待ちたい</h1>

<p>Thread#joinは特定のThreadを待ちます。<br/>
Webサーバーの例では複数のProcessを管理していました。<br/>
同様のことをThreadで実行するには、<code>ThreadsWait</code>を使います。</p>

<pre><code class="rb">require 'thwait'
worker_threads = []
5.times {
  worker_threads &lt;&lt; Thread.start {
     puts "スレッド1 id : #{Thread.current} "
     sleep 1
  }
}
# ThreadsWait.all_waitsで全てのThreadの処理終了を待つ
ThreadsWait.all_waits(worker_threads)
puts "メインスレッド id : #{Thread.current} #{access_count += 1}" =&gt; 1
</code></pre>

<h1>複数Threadでリクエストを処理するWebサーバー</h1>

<p>それでは上記を踏まえて、複数Threadで処理するWebサーバーを書いてみます。</p>

<pre><code class="rb">#!/usr/bin/env ruby

require 'socket'
require 'time'
require 'thwait'

socket = TCPServer.open '127.0.0.1', 8080

access_count = 0

worker_threads = []
5.times {
  # access_countはThreadローカルにする
  worker_threads &lt;&lt; Thread.start(access_count){|ac|
    # threadの処理
    loop {
      response_body = "Hello Browser! #{ac += 1}"
      connection = socket.accept
      connection.puts ['HTTP/1.1 200 OK',
                     "Date: #{Time.now.httpdate}",
                     'Server: Ruby',
                     'Content-Type: text/html; charset=utf-8',
                     "Content-Length: #{response_body.length}\r\n\r\n"].join("\r\n")
      connection.puts response_body
      connection.close
    }
  }
}

# メインスレッドを待ちにする
ThreadsWait.all_waits(worker_threads)
</code></pre>

<p>実際のところ、<code>socket</code>を複数Threadで共有した場合どうなるか、とかは調査する必要がありますね。<br/>
ただ、Threadで置き換えることもできたということで。<br/>
これでも一応動きます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RubyのProcessを利用したWebサーバーを作る]]></title>
    <link href="http://jangajan.com/blog/2014/09/05/unix-process-socket-server-in-ruby/"/>
    <updated>2014-09-05T19:08:20+09:00</updated>
    <id>http://jangajan.com/blog/2014/09/05/unix-process-socket-server-in-ruby</id>
    <content type="html"><![CDATA[<p>積読消化シリーズです。<br/>
<a href="http://tatsu-zine.com/books/naruhounix">なるほどUnixプロセス ― Rubyで学ぶUnixの基礎</a><br/>
簡単なWebサーバーを作ります。</p>

<ul>
<li>telnetでアクセスするWebサーバー</li>
<li>ブラウザでアクセスするWebサーバー</li>
<li>forkしたProcessでリクエストを処理するWebサーバー</li>
</ul>


<h1>telnetでアクセスするWebサーバー</h1>

<p>まずはtelnetでアクセスするためのシンプルなWebサーバーを用意します。</p>

<pre><code class="rb">#!/usr/bin/env ruby

require 'socket'

# 127.0.0.1(localhost)で8080ポートで立ち上げる
socket = TCPServer.open '127.0.0.1', 8080

loop {
  connection = socket.accept
  connection.puts 'Hello Readers!'
  connection.close
}
</code></pre>

<p>サーバーを起動し、ターミナルを立ち上げて、telnetでアクセスしてみます。</p>

<pre><code class="sh">telnet 127.0.0.1 8080
=&gt; Hello Readers!
</code></pre>

<p>ただし、このままだとブラウザで<code>http://127.0.0.1:8080</code>にアクセスできません。<br/>
次はブラウザでアクセスできるように修正します。</p>

<h1>ブラウザでアクセスするWebサーバー</h1>

<pre><code class="rb">#!/usr/bin/env ruby

require 'socket'
require 'time'

socket = TCPServer.open '127.0.0.1', 8080

loop {
  connection = socket.accept
  # response headerを設定
  connection.puts ['HTTP/1.1 200 OK',
                   "Date: #{Time.now.httpdate}",
                   'Server: Ruby',
                   'Content-Type: text/html; charset=utf-8',
                   "Content-Length: #{response_body.length}\r\n\r\n"].join("\r\n")
  # response bodyを設定
  connection.puts 'Hello Readers!'
  connection.close
}
</code></pre>

<p>レスポンスのヘッダー情報を追加しました。<br/>
ヘッダーとボディは改行<code>\r\n</code>で区切ります。</p>

<p>これでブラウザでアクセスできるようになりました。</p>

<h1>forkしたProcessでリクエストを処理するWebサーバー</h1>

<p>続いては、アクセスを子プロセスで処理するように変更します。</p>

<pre><code class="rb">#!/usr/bin/env ruby                           
require 'socket'
require 'time'

socket = TCPServer.open '127.0.0.1', 8080

worker_pid = fork do
  # 子プロセスで処理
  loop {
    response_body = 'Hello Browser!'
    connection = socket.accept
    connection.puts ['HTTP/1.1 200 OK',
                   "Date: #{Time.now.httpdate}",
                   'Server: Ruby',
                   'Content-Type: text/html; charset=utf-8',
                   "Content-Length: #{response_body.length}\r\n\r\n"].join("\r\n")
    connection.puts response_body
    connection.close
  }
end

# Signalを受け取ったらprocessをkillする
[:INT, :QUIT].each do |signal|
  Signal.trap(signal) {
    Process.kill(signal, worker_pid)
  }
end

# 親プロセスの処理を待ちにする
Process.waitpid worker_pid
</code></pre>

<p>forkで子プロセスを生成し、リクエストを子プロセスで処理しています。<br/>
親プロセスは子プロセスが処理が完了するまでwaitします。<br/>
(子プロセスはloop処理を行っているため、シグナルを受け取るまでは生き続けます)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UnixのSocketをRubyで扱う]]></title>
    <link href="http://jangajan.com/blog/2014/09/04/unix-process-socket-in-ruby/"/>
    <updated>2014-09-04T03:20:37+09:00</updated>
    <id>http://jangajan.com/blog/2014/09/04/unix-process-socket-in-ruby</id>
    <content type="html"><![CDATA[<p>積読消化シリーズです。<br/>
<a href="http://tatsu-zine.com/books/naruhounix">なるほどUnixプロセス ― Rubyで学ぶUnixの基礎</a><br/>
プロセス間通信を、昨日はpipe、今日はUnixソケットのところです。</p>

<h1>Rubyのプロセス間通信でメッセージ（データグラム）を使う</h1>

<p>データの通信にストリームではなく、メッセージ（データグラム）を利用したい場合、UNIXソケットを使います。</p>

<h2>メッセージ</h2>

<p>昨日の最後にも載せた記事に説明があります。<br/>
メッセージを利用する場合は、１通信が１メッセージとなるため、データのデリミタが不要です。<br/>
(close処理が不要になる)</p>

<p><a href="http://slashdot.jp/journal/160355/TCP%E3%81%A8UDP%E3%81%AE%E9%81%95%E3%81%84">gatekeeperの日記： TCPとUDPの違い</a></p>

<blockquote><p>ところがデータグラム型ではメッセージ単位なのでメッセージの境界が保存されていて、
読み込みと書き込みは常にペアでなければいけない。</p></blockquote>

<p>なお、パイプでは、メッセージは使えません。</p>

<h2>Unixソケット</h2>

<p>Unixソケットは、ソケットを利用したプロセス間通信の方法の一つです。<br/>
メッセージを利用するためにはパイプではなく、Unixソケットでないといけません。<br/>
pipeではできなかったデータの双方向の通信ができます。</p>

<h2>サンプル</h2>

<pre><code class="rb">require 'socket'

# :DGRAMはメッセージ（データグラム）の利用を宣言
child_socket, parent_socket = Socket.pair(:UNIX, :DGRAM, 0)
maxlen = 1000 # メッセージのMaxサイズ
fork do
  # 子プロセスで使用しないsocketを閉じる
  parent_socket.close
  # 対となるSocketからのメッセージの通知を待つ
  instruction = child_socket.recv(maxlen)
  # 対となるSocketへメッセージ送信
  child_socket.send("#{instruction} accomplished!", 0)  
end

# 親プロセスで使用しないsocketを閉じる
child_socket.close
# 対となるSocketへメッセージ送信
parent_socket.send("Heavy lifting", 0)
# 対となるSocketからのメッセージの通知を待って表示する
$stdout.puts parent_socket.recv(maxlen)
# =&gt;Parent_Socket accomplished!
</code></pre>

<p><code>child_socket</code>と<code>parent_socket</code>でそれぞれ、メッセージをやり取りしています。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UnixのパイプをRubyで扱う]]></title>
    <link href="http://jangajan.com/blog/2014/09/03/unix-process-in-ruby/"/>
    <updated>2014-09-03T18:20:35+09:00</updated>
    <id>http://jangajan.com/blog/2014/09/03/unix-process-in-ruby</id>
    <content type="html"><![CDATA[<p>積読消化シリーズです。<br/>
<a href="http://tatsu-zine.com/books/naruhounix">なるほどUnixプロセス ― Rubyで学ぶUnixの基礎</a><br/>
UnixでのパイプをRubyで表すとどうなるか。</p>

<h1>Rubyで扱うパイプ</h1>

<h2>パイプとは</h2>

<p>パイプとは、「単方向のデータの流れ」です。<br/>
パイプでは、２つのプロセス(A,B)で、ストリームを介して、一方通行に通信します。<br/>
(ストリームは最後の方に補足します。データを溜めておく場所のイメージ)</p>

<h2>単一プロセスでのパイプ</h2>

<p>一つのプロセスでの、パイプを表現すると以下の通りです。</p>

<pre><code class="rb">p IO.pipe #=&gt; [#&lt;IO:fd 7&gt;, #&lt;IO:fd 8&gt;]
reader, writer = IO.pipe
# reader =&gt; #&lt;IO:fd 7&gt;
# writer =&gt; #&lt;IO:fd 8&gt;

writer.write("書き込みました。")
writer.close
puts reader.read # =&gt;書き込みました。
</code></pre>

<p>reader(A)、writer(B)とした場合、<code>B =&gt; A</code>というデータの流れは可能ですが、<code>A =&gt; B</code>はできません。<br/>
<code>writer.write</code>でストリームに情報を書き込みます。<br/>
<code>reader.read</code>でストリームに書き込まれた情報を読み込みます。</p>

<h3>メモ</h3>

<ul>
<li><code>reader.read</code>の前に、<code>writer.close</code>をする

<ul>
<li><code>reader.read</code>は区切り文字が見つかるまでストリームを読み込み続けます</li>
<li><code>writer.close</code>することで、ストリームへの書き込みが終了させ、区切り文字を設定します</li>
</ul>
</li>
<li><code>writer.close</code>で閉じたストリームを更新することはできない</li>
</ul>


<h2>親子プロセスでのパイプ</h2>

<pre><code class="rb">reader, writer = IO.pipe
# reader =&gt; #&lt;IO:fd 7&gt;
# writer =&gt; #&lt;IO:fd 8&gt;

# forkにより子プロセスを生成
fork do
  reader.close
  10.times do
    writer.write "Another one bite the dust\n"
  end
end

writer.close
print reader.read
# =&gt; Another one bite the dust
# Another one bite the dust
# Another one bite the dust
# Another one bite the dust
# Another one bite the dust
# Another one bite the dust
# Another one bite the dust
# Another one bite the dust
# Another one bite the dust
# Another one bite the dust
</code></pre>

<p>親プロセス、子プロセスでは、それぞれ使用しないIOインスタンスをcloseしています。<br/>
これは、子プロセスが親のファイルディクリプタを複製して利用するためです。<br/>
ファイルディスクリプタというのは、ストリームの出入り口をイメージすると分かりやすいかもしれません。<br/>
writerやreaderでwrite/readするためのデータの取り出し口ですね。<br/>
* 親プロセスでは、write処理は行わないため、<code>writer.close</code>をします。<br/>
* forkした子プロセスでは、read処理は行わないため、<code>reader.close</code>をします。<br/>
これで、利用しないファイルディクリプタに影響を与えなくなります。</p>

<h3>親子プロセス両方でreader.close</h3>

<p>forkした子プロセスがwriteする前に、親プロセスで<code>reader.close</code>をすると、どうなるでしょうか。</p>

<pre><code class="rb">reader, writer = IO.pipe

fork do
  reader.close
  10.times do
    writer.write "Another one bite the dust\n"
    # =&gt; `write': Broken pipe (Errno::EPIPE)が発生
  end
end

reader.close # この行を追加
writer.close
print reader.read
</code></pre>

<p>親子でreader.closeをすると、書き込んだ情報の出力先がなくなります。<br/>
そのため、子プロセスで書き込みをするとエラーが発生します。</p>

<h2>補足:ストリーム</h2>

<p>スラッシュドットの以下の記事がイメージしやすかったです。
<a href="http://slashdot.jp/journal/160355/TCP%E3%81%A8UDP%E3%81%AE%E9%81%95%E3%81%84">gatekeeperの日記： TCPとUDPの違い</a></p>

<blockquote><p>ストリーム型というのは１個のデーターをためておく場所（ストリーム）があって、
ストリームの性質としては最初に入れたデーターが最初に出てくる。（要はFIFOだな）
&hellip;
それがどういうことになるかというと、ストリーム型では何回かに分けて書き込んだデーターを一気に読み込んだり、
一気に読み込んだり、 逆に一度に書き込んだデーターを細切れで読み出したりできる。
つまり、読み書きの境界はストリームに入った時点で保存されない。</p></blockquote>

<p>ストリームはデータを溜めておく場所で、明示的に終了したよって宣言しないと、データの区切りが分からないものなんですね。<br/>
<code>close</code>することで、データの境界を設定します。<br/>
それまでは好きなだけ<code>write</code>でデータを溜め込みます。<br/>
しかし、<code>read</code>するためには、<code>close</code>でデータの区切りを宣言しないといけません。<br/>
宣言しない限り<code>read</code>でのデータの読み込み処理は完了しないんですね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Github APIを使いやすくするoctokitを触ってみる]]></title>
    <link href="http://jangajan.com/blog/2014/08/18/use-octokit/"/>
    <updated>2014-08-18T00:00:00+09:00</updated>
    <id>http://jangajan.com/blog/2014/08/18/use-octokit</id>
    <content type="html"><![CDATA[<p>GithubのAPIを使いやすくしてくれるoctokitに触ってみました。試すのはcontributorsの一覧の取得です。</p>

<pre><code class="ruby">gem 'octokit'
</code></pre>

<pre><code class="ruby">require 'octokit'

client = Octokit::Client.new access_token: 'xxx'
client.contributors_stats('rails/rails').sort{|a,b| b[:total] &lt;=&gt; a[:total]}.map {|member|
    p member[:author][:login]
}
</code></pre>

<p>access_tokenを利用した方式で試していますが、LOGIN IDとパスワードにも対応しています。</p>
]]></content>
  </entry>
  
</feed>
