<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby-on-rails | JanGaJan.com]]></title>
  <link href="http://jangajan.com/blog/categories/ruby-on-rails/atom.xml" rel="self"/>
  <link href="http://jangajan.com/"/>
  <updated>2015-02-17T18:38:25+09:00</updated>
  <id>http://jangajan.com/</id>
  <author>
    <name><![CDATA[talkto_me]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Gem Reading - Dotenv]]></title>
    <link href="http://jangajan.com/blog/2015/02/16/gem-reading-dotenv/"/>
    <updated>2015-02-16T17:27:40+09:00</updated>
    <id>http://jangajan.com/blog/2015/02/16/gem-reading-dotenv</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/bkeepers/dotenv">dotenv</a>というGemを知ったので覗いてみました。</p>

<!-- more -->


<h1>about dotevn</h1>

<p>読む前にどんなものか簡単に確認。</p>

<h2>これなに？</h2>

<p>環境変数 ENV をファイル管理できるGemです。<a href="http://qiita.com/closer/items/f8d8ba00ae86d7051764">こちら</a>の記事が参考になりました。</p>

<h2>どう使うの？</h2>

<pre><code class="rb Gemfile"># 後でbundle install
gem 'dotenv'
</code></pre>

<p>デフォルトでは<code>.env</code>というファイルの中に、
<code>yml .env
HOGE=1
FUGA=2
</code>
と書いて、<code>.env</code>を読み込むための命令 <code>Dotenv.load</code> を実行すると、 <code>ENV['HOGE']</code> が <code>1</code> を返すようになります。環境変数をわざわざexportコマンドを使ったり、<code>.zshrc</code>といった設定ファイルに書かなくても使えるようになります。<br/>
fixtureを見た感じ<code>=</code>じゃなくて、YAMLっぽく<code>:</code>も使えそう。</p>

<h1>読んでみる</h1>

<h2>2つのGem</h2>

<p>このGemからは2つのGemを利用できます。</p>

<pre><code class="ruby Gemfile">source 'https://rubygems.org'
gemspec :name =&gt; 'dotenv'
gemspec :name =&gt; 'dotenv-rails'
</code></pre>

<p>gemspecファイルも2つあった。<br/>
<code>dotenv</code>というGemはこの機能のベース部分。<code>dotenv-rails</code>というGemは、Railsを利用するときに、<code>dotenv</code>を自動で有効にしてくれるラッパーです。それと、このGemにはCLIのスクリプトも包含しています。</p>

<h2>dotenv.rb</h2>

<p>ここが外部から呼び出すインターフェースのメソッド(load, load!, overload)を定義しています。<code>module Dotenv extend self</code>として、これらをmoduleの特異メソッドにしています。<br/>
環境変数を定義するファイルをこのメソッドの引数として渡せばいいが、引数なしの場合は <code>.env</code> がデフォルト値となります。</p>

<p>まだ分かっていないのですが、 <code>instrument</code> というメソッドは、 <code>Active Support Instrumentation</code> という機能を使っている。  この機能はRails限定。</p>

<p><code>reduce</code>が使われているんだけど、<code>inject</code> とどう使い分けするのかなって疑問に思ったら<a href="http://magazine.rubyist.net/?0038-MapAndCollect#l4">こんな記事</a>がありました。smalltalkとlispの考え方の違いか〜&hellip;実際にはaliasだから使う人の好みが出そう。</p>

<h2>environment.rb</h2>

<p><code>Dotenv::Environment</code>は<code>Hash</code>の子クラス。<code>.env</code>内のkey,value情報を自身に格納して、<code>apply</code> or <code>apply!</code> を呼び出すことで<code>ENV</code>に設定している。<code>apply</code>メソッドの呼び出しは、<code>dotenv.rb</code>で行っている。<code>Dotenv::Environment</code>の<code>initialize</code>の一部として<code>.env</code>の読み込みとパースをやってる。</p>

<h2>parse.rb</h2>

<p>大事なのは<code>call</code>メソッド。ここで<code>.env</code>の内容がパースされる。正規表現弱いんでこのあたりは宿題&hellip;orz<br/>
<code>@@substitutions</code>というクラス変数があるんだけどここには<code>Substitutions</code>のnamespaceにあるクラスの配列が入ってる。<code>.env</code>のvalueに設定できるものとして、</p>

<ol>
<li>コマンドの出力結果</li>
<li>変数展開</li>
</ol>


<p>がある。
1 は <code>Dotenv::Substitutions::Command</code>で処理し、2 は<code>Dotenv::Substitutions::Variable</code>で処理する。  あー、実際にはそうなるように値を設定しているのかな？</p>

<p>Substitutions.constants のところでクラス名が定数だということがわかった。</p>

<h2>rails.rb</h2>

<p>デフォルトでは、<code>before_configuration</code>のときに、<code>.env</code>を読み込む。<code>dotenv</code>と違い、ファイル名は<code>.env.local</code>,<code>.env.#{Rails.env}</code>もデフォルトで読み込み対象となる。</p>

<p>それと、上述の<code>Active Support Instrumentation</code>をspringによるファイル変更時のENV再設定に利用しているっぽい。この通知の仕組み？をもうちょっと掘り下げてみようかな。</p>

<h1>終わりに</h1>

<p>英語が堪能は方は<a href="http://blog.mah-lab.com/2014/08/15/dotenv/">こちら</a>が参考になるかも。全然内容が頭の中に入ってこなかったのでもっとリスニング練習しよう。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Railsのexists?とfind_byはどっちが早いのか]]></title>
    <link href="http://jangajan.com/blog/2014/11/10/exists-or-find-by-in-rails/"/>
    <updated>2014-11-10T16:01:44+09:00</updated>
    <id>http://jangajan.com/blog/2014/11/10/exists-or-find-by-in-rails</id>
    <content type="html"><![CDATA[<p>Railsで特定するレコードが存在するかbooleanで取得したい時、</p>

<ol>
<li>Table.exists?(a: id)</li>
<li>!!Table.find_by(a: id)</li>
</ol>


<p>いずれのやり方のほうが処理が早いか計測してみました。</p>

<!-- more -->


<h1>ケース</h1>

<p>環境は、<code>Rails 4.1.7</code>と<code>ruby 2.1.4</code>です。</p>

<ul>
<li>1万件のレコードがあるVoteテーブルに対して、voting_user_idを検索条件に指定して該当するレコードがあるか確認する。</li>
<li>Vote.voting_user_idにはIndexをつける</li>
<li>1万回問い合わせした時間で比較</li>
</ul>


<p>1の場合、<code>Vote.exists?(voting_user_id: 1098)</code><br/>
2の場合、<code>!!Vote.find_by(voting_user_id: 1098)</code></p>

<p>となります。</p>

<h1>計測</h1>

<p>計測してみました。Databaseはsqlite3です。</p>

<pre><code class="rb"># 1.exists?のケース
Benchmark.realtime { 10000.times {|e|Vote.exists?(voting_user_id: 1098)}}
# SQL: SELECT  1 AS one FROM "votes"  WHERE "votes"."voting_user_id" = 1098 LIMIT 1
# =&gt; 6.658646

# 2.find_byのケース
Benchmark.realtime { 10000.times {|e|!!Vote.find_by(voting_user_id: 1098)}}
# SQL: SELECT  "votes".* FROM "votes"  WHERE "votes"."voting_user_id" = 1098 LIMIT 1
# =&gt; 5.506756
</code></pre>

<p>find_byのほうが早いんですね。取得結果の情報が多い分、find_byのほうがメモリは食ってそうなので、遅いかなと思ったら想像と逆の結果でした。</p>

<h1>Postgresqlで試してみる</h1>

<p>アプリをHeroku+Postgresqlで動かす機会が多いので、ローカルのPostgresqlで試してみます。</p>

<pre><code class="rb"># 1.exists?のケース
Benchmark.realtime { 10000.times {|e|Vote.exists?(voting_user_id: 1098)}}
# SQL: SELECT  1 AS one FROM "votes"  WHERE "votes"."voting_user_id" = 1098 LIMIT 1
# =&gt; 9.905989

# 2.find_byのケース
Benchmark.realtime { 10000.times {|e|!!Vote.find_by(voting_user_id: 1098)}}
# SQL: SELECT  "votes".* FROM "votes"  WHERE "votes"."voting_user_id" = 1098 LIMIT 1
# =&gt; 7.289921
</code></pre>

<p>やっぱり、find_byの方が早いのかー。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[herokuで動くRailsアプリケーションにNew Relicを入れる]]></title>
    <link href="http://jangajan.com/blog/2014/10/20/use-new-relic-in-rails4-at-heroku/"/>
    <updated>2014-10-20T15:30:52+09:00</updated>
    <id>http://jangajan.com/blog/2014/10/20/use-new-relic-in-rails4-at-heroku</id>
    <content type="html"><![CDATA[<p>Rails4アプリにNew Relicを入れます。<br/>
herokuで動かす場合はadd-onとかの設定が必要でした。</p>

<p><a href="https://docs.newrelic.com/docs/agents/ruby-agent/installation-configuration/ruby-agent-installation">New Relicの本家</a>と<a href="https://devcenter.heroku.com/articles/newrelic#ruby-configuration">herokuのNew Relicの適用ページ</a>が参考になります。</p>

<!-- more -->


<p>New Relicへの登録をすませると、手順ページが表示されていきます。</p>

<h1>New Relicの設定</h1>

<h2>Choose your language</h2>

<p>言語をRubyに選択します。</p>

<h2>Get your license key</h2>

<p>Generate license keyを単にクリックするだけです。<br/>
これで、newrelic.ymlをダウンロードできます。</p>

<h2>Install the New Relic agent with bundler</h2>

<p>Gemfileの修正と、gemのインストールを実行します。</p>

<h2>Download newrelic.yml</h2>

<p>license keyを生成すると、Donwload the newrelic.yml fileが有効になりますので、クリックしてファイルを取得します。
その後、<code>${APP_ROOT}/config/newrelic.yml</code>にダウンロードしたファイルを配置します。</p>

<h2>アプリ名の設定</h2>

<p>newrelic.ymlにアプリ名を設定します。</p>

<pre><code class="yaml config/newrelic.yml">common: &amp;default_settings
...
  app_name: #{アプリケーション名}
...
</code></pre>

<h2>Postgles</h2>

<p>postgresqlの場合は特殊な設定が必要になります。
なくても動きますが,New Relicの一部機能は動作しません。</p>

<pre><code class="yaml config/newrelic.yml">common: &amp;default_settings
  transaction_tracer:
    explain_enabled: false
</code></pre>

<h2>ローカルで確認</h2>

<p>この状態でローカルで確認できます。<br/>
ローカルがPostgresqlでなければ直前の対応は不要かもしれません。</p>

<p><a href="http://localhost:3000/newrelic">http://localhost:3000/newrelic</a></p>

<h1>herokuの設定</h1>

<p>herokuではadd-onでnew relicと連携します。</p>

<h2>Add-onの設定</h2>

<p>add-on追加のためにはクレジットカードの情報が必須です。
(無料プランがあります)</p>

<p><a href="https://addons.heroku.com/newrelic">New RelicのAdd-onページ</a>から設定を有効にしてください。</p>

<h2>環境変数の設定</h2>

<p><code>heroku config</code>で設定を変更。</p>

<pre><code class="sh">heroku config:set NEW_RELIC_APP_NAME="各自のアプリケーション名"
heroku config:set RACK_ENV=production
</code></pre>

<h2>本番で確認</h2>

<p>このままherokuへのpushが成功した後、数分してからNew Relicにアクセスすれば接続確認できます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Factorygirlの読み込みでエラー]]></title>
    <link href="http://jangajan.com/blog/2014/10/08/require-rspec/"/>
    <updated>2014-10-08T14:19:07+09:00</updated>
    <id>http://jangajan.com/blog/2014/10/08/require-rspec</id>
    <content type="html"><![CDATA[<p>パーフェクトRuby on Rails の7章のFactoryGirlを省略するところ(リスト7.12)で<code>uninitialized constant FactoryGirl (NameError)</code>が発生しました。</p>

<!-- more -->


<p><code>factory_girl_rails</code>を読み込んであげればおーけーです。</p>

<pre><code class="rb spec/spec_helper.rb">require 'factory_girl_rails'

RSpec.configure do |config|
  config.include FactoryGirl::Syntax::Methods
end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails4.1でherokuへのデプロイに失敗(Missing `secret_key_base`)]]></title>
    <link href="http://jangajan.com/blog/2014/10/05/secrets-dot-yml-on-heroku-in-rails4-dot-1/"/>
    <updated>2014-10-05T01:14:13+09:00</updated>
    <id>http://jangajan.com/blog/2014/10/05/secrets-dot-yml-on-heroku-in-rails4-dot-1</id>
    <content type="html"><![CDATA[<p>Rails4.1でherokuへのデプロイに失敗(Missing <code>secret_key_base</code>)</p>

<p>Rails4.1から<code>secrets.yml</code>がサポートされました。<br/>
これの扱いが良くわかっていなかったため、heroku push後、以下のエラーが発生してアプリ起動に失敗しました。</p>

<blockquote><p>app error: Missing <code>secret_key_base</code> for &lsquo;production&rsquo; environment, set this value in <code>config/secrets.yml</code> (RuntimeError)</p></blockquote>

<!-- more -->


<h1>解決策</h1>

<p>ちなみに、heroku create済みです。</p>

<h2>secrets.ymlをgitで管理する</h2>

<p><code>.gitignore</code>に<code>/config/secrets.yml</code>を含めてしまっている場合は、削除してください。<br/>
その後、git管理化におくため、commitします。</p>

<p>productionの<code>secret_key_base</code>は環境変数から取得するようになっているため、herokuの環境変数に<code>SECRET_KEY_BASE</code>を設定する必要があります。</p>

<h2>環境変数SECRET_KEY_BASEを設定する</h2>

<p>やり方が２通りあります。</p>

<h3>heroku_secretsを使う</h3>

<p>この方法では、<a href="https://github.com/alexpeattie/heroku_secrets">heroku_secrets</a>というgemを利用することでherokuコマンドを打つ必要はありません。</p>

<h4>gemのインストール</h4>

<p>Gemfileにgemを追加して、bundle updateを実行します。</p>

<pre><code class="rb Gemfile">gem 'heroku_secrets', github: 'alexpeattie/heroku_secrets'
</code></pre>

<h4>rakeコマンドを実行</h4>

<p>その後、rakeコマンドを実行します。</p>

<pre><code class="sh">bundle exec rake heroku:secrets[app-name] RAILS_ENV=production
</code></pre>

<p>もう一つの方も作業量としては変わらなそうですね。</p>

<h3>heroku configで環境変数を設定する</h3>

<p>この方法では、heroku config:add で環境変数を直接設定します。</p>

<h4>設定値を作成する</h4>

<p>環境変数に設定する値を取得します。</p>

<pre><code class="sh">bundle exec rake secret RAILS_ENV=production
</code></pre>

<h4>herokuの環境変数を設定する</h4>

<p>上記の実行結果を値とした環境変数(SECRET_KEY_BASE)を設定します。</p>

<pre><code class="sh">heroku config:add SECRET_KEY_BASE=rake secretの実行結果
</code></pre>
]]></content>
  </entry>
  
</feed>
